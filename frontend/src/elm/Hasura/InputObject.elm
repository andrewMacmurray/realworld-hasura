-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Hasura.InputObject exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Hasura.Enum.Articles_constraint
import Hasura.Enum.Articles_update_column
import Hasura.Enum.Order_by
import Hasura.Interface
import Hasura.Object
import Hasura.Scalar
import Hasura.ScalarCodecs
import Hasura.Union
import Json.Decode as Decode


buildArticles_bool_exp : (Articles_bool_expOptionalFields -> Articles_bool_expOptionalFields) -> Articles_bool_exp
buildArticles_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, about = Absent, author = Absent, content = Absent, created_at = Absent, title = Absent }
    in
    Articles_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, about = optionals.about, author = optionals.author, content = optionals.content, created_at = optionals.created_at, title = optionals.title }


type alias Articles_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Articles_bool_exp))
    , not_ : OptionalArgument Articles_bool_exp
    , or_ : OptionalArgument (List (Maybe Articles_bool_exp))
    , about : OptionalArgument String_comparison_exp
    , author : OptionalArgument Users_bool_exp
    , content : OptionalArgument String_comparison_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , title : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Articles_bool_exp` attributes. Note that this type
needs to use the `Articles_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Articles_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Articles_bool_exp))
    , not_ : OptionalArgument Articles_bool_exp
    , or_ : OptionalArgument (List (Maybe Articles_bool_exp))
    , about : OptionalArgument String_comparison_exp
    , author : OptionalArgument Users_bool_exp
    , content : OptionalArgument String_comparison_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , title : OptionalArgument String_comparison_exp
    }


{-| Type for the Articles\_bool\_exp input object.
-}
type Articles_bool_exp
    = Articles_bool_exp Articles_bool_expRaw


{-| Encode a Articles\_bool\_exp into a value that can be used as an argument.
-}
encodeArticles_bool_exp : Articles_bool_exp -> Value
encodeArticles_bool_exp (Articles_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeArticles_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeArticles_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeArticles_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "about", encodeString_comparison_exp |> Encode.optional input.about ), ( "author", encodeUsers_bool_exp |> Encode.optional input.author ), ( "content", encodeString_comparison_exp |> Encode.optional input.content ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input.created_at ), ( "title", encodeString_comparison_exp |> Encode.optional input.title ) ]


buildArticles_on_conflict : Articles_on_conflictRequiredFields -> (Articles_on_conflictOptionalFields -> Articles_on_conflictOptionalFields) -> Articles_on_conflict
buildArticles_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Articles_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Articles_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Articles_constraint.Articles_constraint
    , update_columns : List Hasura.Enum.Articles_update_column.Articles_update_column
    }


type alias Articles_on_conflictOptionalFields =
    { where_ : OptionalArgument Articles_bool_exp }


{-| Type alias for the `Articles_on_conflict` attributes. Note that this type
needs to use the `Articles_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Articles_on_conflictRaw =
    { constraint : Hasura.Enum.Articles_constraint.Articles_constraint
    , update_columns : List Hasura.Enum.Articles_update_column.Articles_update_column
    , where_ : OptionalArgument Articles_bool_exp
    }


{-| Type for the Articles\_on\_conflict input object.
-}
type Articles_on_conflict
    = Articles_on_conflict Articles_on_conflictRaw


{-| Encode a Articles\_on\_conflict into a value that can be used as an argument.
-}
encodeArticles_on_conflict : Articles_on_conflict -> Value
encodeArticles_on_conflict (Articles_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Articles_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Articles_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodeArticles_bool_exp |> Encode.optional input.where_ ) ]


buildArticles_order_by : (Articles_order_byOptionalFields -> Articles_order_byOptionalFields) -> Articles_order_by
buildArticles_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { about = Absent, author = Absent, content = Absent, created_at = Absent, title = Absent }
    in
    { about = optionals.about, author = optionals.author, content = optionals.content, created_at = optionals.created_at, title = optionals.title }


type alias Articles_order_byOptionalFields =
    { about : OptionalArgument Hasura.Enum.Order_by.Order_by
    , author : OptionalArgument Users_order_by
    , content : OptionalArgument Hasura.Enum.Order_by.Order_by
    , created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , title : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Articles\_order\_by input object.
-}
type alias Articles_order_by =
    { about : OptionalArgument Hasura.Enum.Order_by.Order_by
    , author : OptionalArgument Users_order_by
    , content : OptionalArgument Hasura.Enum.Order_by.Order_by
    , created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , title : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Articles\_order\_by into a value that can be used as an argument.
-}
encodeArticles_order_by : Articles_order_by -> Value
encodeArticles_order_by input =
    Encode.maybeObject
        [ ( "about", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.about ), ( "author", encodeUsers_order_by |> Encode.optional input.author ), ( "content", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.content ), ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "title", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.title ) ]


buildArticles_pk_columns_input : Articles_pk_columns_inputRequiredFields -> Articles_pk_columns_input
buildArticles_pk_columns_input required =
    { id = required.id }


type alias Articles_pk_columns_inputRequiredFields =
    { id : Int }


{-| Type for the Articles\_pk\_columns\_input input object.
-}
type alias Articles_pk_columns_input =
    { id : Int }


{-| Encode a Articles\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeArticles_pk_columns_input : Articles_pk_columns_input -> Value
encodeArticles_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", Encode.int input.id |> Just ) ]


buildArticles_set_input : (Articles_set_inputOptionalFields -> Articles_set_inputOptionalFields) -> Articles_set_input
buildArticles_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { about = Absent, content = Absent, title = Absent }
    in
    { about = optionals.about, content = optionals.content, title = optionals.title }


type alias Articles_set_inputOptionalFields =
    { about : OptionalArgument String
    , content : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Type for the Articles\_set\_input input object.
-}
type alias Articles_set_input =
    { about : OptionalArgument String
    , content : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Encode a Articles\_set\_input into a value that can be used as an argument.
-}
encodeArticles_set_input : Articles_set_input -> Value
encodeArticles_set_input input =
    Encode.maybeObject
        [ ( "about", Encode.string |> Encode.optional input.about ), ( "content", Encode.string |> Encode.optional input.content ), ( "title", Encode.string |> Encode.optional input.title ) ]


buildJson_comparison_exp : (Json_comparison_expOptionalFields -> Json_comparison_expOptionalFields) -> Json_comparison_exp
buildJson_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Json_comparison_expOptionalFields =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Json
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Json
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Json
    , in_ : OptionalArgument (List Hasura.ScalarCodecs.Json)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Json
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Json
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Json
    , nin_ : OptionalArgument (List Hasura.ScalarCodecs.Json)
    }


{-| Type for the Json\_comparison\_exp input object.
-}
type alias Json_comparison_exp =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Json
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Json
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Json
    , in_ : OptionalArgument (List Hasura.ScalarCodecs.Json)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Json
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Json
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Json
    , nin_ : OptionalArgument (List Hasura.ScalarCodecs.Json)
    }


{-| Encode a Json\_comparison\_exp into a value that can be used as an argument.
-}
encodeJson_comparison_exp : Json_comparison_exp -> Value
encodeJson_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.optional input.eq_ ), ( "_gt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.optional input.gt_ ), ( "_gte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.optional input.gte_ ), ( "_in", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.optional input.lt_ ), ( "_lte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.optional input.lte_ ), ( "_neq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.optional input.neq_ ), ( "_nin", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildString_comparison_exp : (String_comparison_expOptionalFields -> String_comparison_expOptionalFields) -> String_comparison_exp
buildString_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]


buildTimestamptz_comparison_exp : (Timestamptz_comparison_expOptionalFields -> Timestamptz_comparison_expOptionalFields) -> Timestamptz_comparison_exp
buildTimestamptz_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Timestamptz_comparison_expOptionalFields =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    }


{-| Type for the Timestamptz\_comparison\_exp input object.
-}
type alias Timestamptz_comparison_exp =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    }


{-| Encode a Timestamptz\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamptz_comparison_exp : Timestamptz_comparison_exp -> Value
encodeTimestamptz_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.eq_ ), ( "_gt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gt_ ), ( "_gte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gte_ ), ( "_in", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lt_ ), ( "_lte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lte_ ), ( "_neq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.neq_ ), ( "_nin", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildUsers_bool_exp : (Users_bool_expOptionalFields -> Users_bool_expOptionalFields) -> Users_bool_exp
buildUsers_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, articles = Absent, email = Absent, username = Absent }
    in
    Users_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, articles = optionals.articles, email = optionals.email, username = optionals.username }


type alias Users_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Users_bool_exp))
    , not_ : OptionalArgument Users_bool_exp
    , or_ : OptionalArgument (List (Maybe Users_bool_exp))
    , articles : OptionalArgument Articles_bool_exp
    , email : OptionalArgument String_comparison_exp
    , username : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Users_bool_exp` attributes. Note that this type
needs to use the `Users_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Users_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Users_bool_exp))
    , not_ : OptionalArgument Users_bool_exp
    , or_ : OptionalArgument (List (Maybe Users_bool_exp))
    , articles : OptionalArgument Articles_bool_exp
    , email : OptionalArgument String_comparison_exp
    , username : OptionalArgument String_comparison_exp
    }


{-| Type for the Users\_bool\_exp input object.
-}
type Users_bool_exp
    = Users_bool_exp Users_bool_expRaw


{-| Encode a Users\_bool\_exp into a value that can be used as an argument.
-}
encodeUsers_bool_exp : Users_bool_exp -> Value
encodeUsers_bool_exp (Users_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeUsers_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeUsers_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeUsers_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "articles", encodeArticles_bool_exp |> Encode.optional input.articles ), ( "email", encodeString_comparison_exp |> Encode.optional input.email ), ( "username", encodeString_comparison_exp |> Encode.optional input.username ) ]


buildUsers_order_by : (Users_order_byOptionalFields -> Users_order_byOptionalFields) -> Users_order_by
buildUsers_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { email = Absent, username = Absent }
    in
    { email = optionals.email, username = optionals.username }


type alias Users_order_byOptionalFields =
    { email : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Users\_order\_by input object.
-}
type alias Users_order_by =
    { email : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Users\_order\_by into a value that can be used as an argument.
-}
encodeUsers_order_by : Users_order_by -> Value
encodeUsers_order_by input =
    Encode.maybeObject
        [ ( "email", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.email ), ( "username", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.username ) ]


buildUsers_pk_columns_input : Users_pk_columns_inputRequiredFields -> Users_pk_columns_input
buildUsers_pk_columns_input required =
    { id = required.id }


type alias Users_pk_columns_inputRequiredFields =
    { id : Int }


{-| Type for the Users\_pk\_columns\_input input object.
-}
type alias Users_pk_columns_input =
    { id : Int }


{-| Encode a Users\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeUsers_pk_columns_input : Users_pk_columns_input -> Value
encodeUsers_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", Encode.int input.id |> Just ) ]
