-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Hasura.InputObject exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Hasura.Enum.Articles_constraint
import Hasura.Enum.Articles_update_column
import Hasura.Enum.Order_by
import Hasura.Interface
import Hasura.Object
import Hasura.Scalar
import Hasura.ScalarCodecs
import Hasura.Union
import Json.Decode as Decode


buildArticles_arr_rel_insert_input : Articles_arr_rel_insert_inputRequiredFields -> (Articles_arr_rel_insert_inputOptionalFields -> Articles_arr_rel_insert_inputOptionalFields) -> Articles_arr_rel_insert_input
buildArticles_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Articles_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Articles_arr_rel_insert_inputRequiredFields =
    { data : List Articles_insert_input }


type alias Articles_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Articles_on_conflict }


{-| Type alias for the `Articles_arr_rel_insert_input` attributes. Note that this type
needs to use the `Articles_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Articles_arr_rel_insert_inputRaw =
    { data : List Articles_insert_input
    , on_conflict : OptionalArgument Articles_on_conflict
    }


{-| Type for the Articles\_arr\_rel\_insert\_input input object.
-}
type Articles_arr_rel_insert_input
    = Articles_arr_rel_insert_input Articles_arr_rel_insert_inputRaw


{-| Encode a Articles\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeArticles_arr_rel_insert_input : Articles_arr_rel_insert_input -> Value
encodeArticles_arr_rel_insert_input (Articles_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeArticles_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeArticles_on_conflict |> Encode.optional input.on_conflict ) ]


buildArticles_bool_exp : (Articles_bool_expOptionalFields -> Articles_bool_expOptionalFields) -> Articles_bool_exp
buildArticles_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, about = Absent, author = Absent, content = Absent, created_at = Absent, id = Absent, likes = Absent, tags = Absent, title = Absent }
    in
    Articles_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, about = optionals.about, author = optionals.author, content = optionals.content, created_at = optionals.created_at, id = optionals.id, likes = optionals.likes, tags = optionals.tags, title = optionals.title }


type alias Articles_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Articles_bool_exp))
    , not_ : OptionalArgument Articles_bool_exp
    , or_ : OptionalArgument (List (Maybe Articles_bool_exp))
    , about : OptionalArgument String_comparison_exp
    , author : OptionalArgument Users_bool_exp
    , content : OptionalArgument String_comparison_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , likes : OptionalArgument Likes_bool_exp
    , tags : OptionalArgument Tags_bool_exp
    , title : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Articles_bool_exp` attributes. Note that this type
needs to use the `Articles_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Articles_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Articles_bool_exp))
    , not_ : OptionalArgument Articles_bool_exp
    , or_ : OptionalArgument (List (Maybe Articles_bool_exp))
    , about : OptionalArgument String_comparison_exp
    , author : OptionalArgument Users_bool_exp
    , content : OptionalArgument String_comparison_exp
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , likes : OptionalArgument Likes_bool_exp
    , tags : OptionalArgument Tags_bool_exp
    , title : OptionalArgument String_comparison_exp
    }


{-| Type for the Articles\_bool\_exp input object.
-}
type Articles_bool_exp
    = Articles_bool_exp Articles_bool_expRaw


{-| Encode a Articles\_bool\_exp into a value that can be used as an argument.
-}
encodeArticles_bool_exp : Articles_bool_exp -> Value
encodeArticles_bool_exp (Articles_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeArticles_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeArticles_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeArticles_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "about", encodeString_comparison_exp |> Encode.optional input.about ), ( "author", encodeUsers_bool_exp |> Encode.optional input.author ), ( "content", encodeString_comparison_exp |> Encode.optional input.content ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input.created_at ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "likes", encodeLikes_bool_exp |> Encode.optional input.likes ), ( "tags", encodeTags_bool_exp |> Encode.optional input.tags ), ( "title", encodeString_comparison_exp |> Encode.optional input.title ) ]


buildArticles_insert_input : (Articles_insert_inputOptionalFields -> Articles_insert_inputOptionalFields) -> Articles_insert_input
buildArticles_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { about = Absent, content = Absent, likes = Absent, tags = Absent, title = Absent }
    in
    Articles_insert_input { about = optionals.about, content = optionals.content, likes = optionals.likes, tags = optionals.tags, title = optionals.title }


type alias Articles_insert_inputOptionalFields =
    { about : OptionalArgument String
    , content : OptionalArgument String
    , likes : OptionalArgument Likes_arr_rel_insert_input
    , tags : OptionalArgument Tags_arr_rel_insert_input
    , title : OptionalArgument String
    }


{-| Type alias for the `Articles_insert_input` attributes. Note that this type
needs to use the `Articles_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Articles_insert_inputRaw =
    { about : OptionalArgument String
    , content : OptionalArgument String
    , likes : OptionalArgument Likes_arr_rel_insert_input
    , tags : OptionalArgument Tags_arr_rel_insert_input
    , title : OptionalArgument String
    }


{-| Type for the Articles\_insert\_input input object.
-}
type Articles_insert_input
    = Articles_insert_input Articles_insert_inputRaw


{-| Encode a Articles\_insert\_input into a value that can be used as an argument.
-}
encodeArticles_insert_input : Articles_insert_input -> Value
encodeArticles_insert_input (Articles_insert_input input) =
    Encode.maybeObject
        [ ( "about", Encode.string |> Encode.optional input.about ), ( "content", Encode.string |> Encode.optional input.content ), ( "likes", encodeLikes_arr_rel_insert_input |> Encode.optional input.likes ), ( "tags", encodeTags_arr_rel_insert_input |> Encode.optional input.tags ), ( "title", Encode.string |> Encode.optional input.title ) ]


buildArticles_obj_rel_insert_input : Articles_obj_rel_insert_inputRequiredFields -> (Articles_obj_rel_insert_inputOptionalFields -> Articles_obj_rel_insert_inputOptionalFields) -> Articles_obj_rel_insert_input
buildArticles_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Articles_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Articles_obj_rel_insert_inputRequiredFields =
    { data : Articles_insert_input }


type alias Articles_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Articles_on_conflict }


{-| Type alias for the `Articles_obj_rel_insert_input` attributes. Note that this type
needs to use the `Articles_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Articles_obj_rel_insert_inputRaw =
    { data : Articles_insert_input
    , on_conflict : OptionalArgument Articles_on_conflict
    }


{-| Type for the Articles\_obj\_rel\_insert\_input input object.
-}
type Articles_obj_rel_insert_input
    = Articles_obj_rel_insert_input Articles_obj_rel_insert_inputRaw


{-| Encode a Articles\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeArticles_obj_rel_insert_input : Articles_obj_rel_insert_input -> Value
encodeArticles_obj_rel_insert_input (Articles_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeArticles_insert_input input.data |> Just ), ( "on_conflict", encodeArticles_on_conflict |> Encode.optional input.on_conflict ) ]


buildArticles_on_conflict : Articles_on_conflictRequiredFields -> (Articles_on_conflictOptionalFields -> Articles_on_conflictOptionalFields) -> Articles_on_conflict
buildArticles_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Articles_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Articles_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Articles_constraint.Articles_constraint
    , update_columns : List Hasura.Enum.Articles_update_column.Articles_update_column
    }


type alias Articles_on_conflictOptionalFields =
    { where_ : OptionalArgument Articles_bool_exp }


{-| Type alias for the `Articles_on_conflict` attributes. Note that this type
needs to use the `Articles_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Articles_on_conflictRaw =
    { constraint : Hasura.Enum.Articles_constraint.Articles_constraint
    , update_columns : List Hasura.Enum.Articles_update_column.Articles_update_column
    , where_ : OptionalArgument Articles_bool_exp
    }


{-| Type for the Articles\_on\_conflict input object.
-}
type Articles_on_conflict
    = Articles_on_conflict Articles_on_conflictRaw


{-| Encode a Articles\_on\_conflict into a value that can be used as an argument.
-}
encodeArticles_on_conflict : Articles_on_conflict -> Value
encodeArticles_on_conflict (Articles_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Articles_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Articles_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodeArticles_bool_exp |> Encode.optional input.where_ ) ]


buildArticles_order_by : (Articles_order_byOptionalFields -> Articles_order_byOptionalFields) -> Articles_order_by
buildArticles_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { about = Absent, author = Absent, content = Absent, created_at = Absent, id = Absent, likes_aggregate = Absent, title = Absent }
    in
    { about = optionals.about, author = optionals.author, content = optionals.content, created_at = optionals.created_at, id = optionals.id, likes_aggregate = optionals.likes_aggregate, title = optionals.title }


type alias Articles_order_byOptionalFields =
    { about : OptionalArgument Hasura.Enum.Order_by.Order_by
    , author : OptionalArgument Users_order_by
    , content : OptionalArgument Hasura.Enum.Order_by.Order_by
    , created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , likes_aggregate : OptionalArgument Likes_aggregate_order_by
    , title : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Articles\_order\_by input object.
-}
type alias Articles_order_by =
    { about : OptionalArgument Hasura.Enum.Order_by.Order_by
    , author : OptionalArgument Users_order_by
    , content : OptionalArgument Hasura.Enum.Order_by.Order_by
    , created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , likes_aggregate : OptionalArgument Likes_aggregate_order_by
    , title : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Articles\_order\_by into a value that can be used as an argument.
-}
encodeArticles_order_by : Articles_order_by -> Value
encodeArticles_order_by input =
    Encode.maybeObject
        [ ( "about", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.about ), ( "author", encodeUsers_order_by |> Encode.optional input.author ), ( "content", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.content ), ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "likes_aggregate", encodeLikes_aggregate_order_by |> Encode.optional input.likes_aggregate ), ( "title", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.title ) ]


buildArticles_pk_columns_input : Articles_pk_columns_inputRequiredFields -> Articles_pk_columns_input
buildArticles_pk_columns_input required =
    { id = required.id }


type alias Articles_pk_columns_inputRequiredFields =
    { id : Int }


{-| Type for the Articles\_pk\_columns\_input input object.
-}
type alias Articles_pk_columns_input =
    { id : Int }


{-| Encode a Articles\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeArticles_pk_columns_input : Articles_pk_columns_input -> Value
encodeArticles_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", Encode.int input.id |> Just ) ]


buildArticles_set_input : (Articles_set_inputOptionalFields -> Articles_set_inputOptionalFields) -> Articles_set_input
buildArticles_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { about = Absent, content = Absent, title = Absent }
    in
    { about = optionals.about, content = optionals.content, title = optionals.title }


type alias Articles_set_inputOptionalFields =
    { about : OptionalArgument String
    , content : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Type for the Articles\_set\_input input object.
-}
type alias Articles_set_input =
    { about : OptionalArgument String
    , content : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Encode a Articles\_set\_input into a value that can be used as an argument.
-}
encodeArticles_set_input : Articles_set_input -> Value
encodeArticles_set_input input =
    Encode.maybeObject
        [ ( "about", Encode.string |> Encode.optional input.about ), ( "content", Encode.string |> Encode.optional input.content ), ( "title", Encode.string |> Encode.optional input.title ) ]


buildFollows_arr_rel_insert_input : Follows_arr_rel_insert_inputRequiredFields -> Follows_arr_rel_insert_input
buildFollows_arr_rel_insert_input required =
    { data = required.data }


type alias Follows_arr_rel_insert_inputRequiredFields =
    { data : List Follows_insert_input }


{-| Type for the Follows\_arr\_rel\_insert\_input input object.
-}
type alias Follows_arr_rel_insert_input =
    { data : List Follows_insert_input }


{-| Encode a Follows\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeFollows_arr_rel_insert_input : Follows_arr_rel_insert_input -> Value
encodeFollows_arr_rel_insert_input input =
    Encode.maybeObject
        [ ( "data", (encodeFollows_insert_input |> Encode.list) input.data |> Just ) ]


buildFollows_bool_exp : (Follows_bool_expOptionalFields -> Follows_bool_expOptionalFields) -> Follows_bool_exp
buildFollows_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, following_id = Absent, user = Absent }
    in
    Follows_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, following_id = optionals.following_id, user = optionals.user }


type alias Follows_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Follows_bool_exp))
    , not_ : OptionalArgument Follows_bool_exp
    , or_ : OptionalArgument (List (Maybe Follows_bool_exp))
    , following_id : OptionalArgument Int_comparison_exp
    , user : OptionalArgument Users_bool_exp
    }


{-| Type alias for the `Follows_bool_exp` attributes. Note that this type
needs to use the `Follows_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Follows_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Follows_bool_exp))
    , not_ : OptionalArgument Follows_bool_exp
    , or_ : OptionalArgument (List (Maybe Follows_bool_exp))
    , following_id : OptionalArgument Int_comparison_exp
    , user : OptionalArgument Users_bool_exp
    }


{-| Type for the Follows\_bool\_exp input object.
-}
type Follows_bool_exp
    = Follows_bool_exp Follows_bool_expRaw


{-| Encode a Follows\_bool\_exp into a value that can be used as an argument.
-}
encodeFollows_bool_exp : Follows_bool_exp -> Value
encodeFollows_bool_exp (Follows_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeFollows_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeFollows_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeFollows_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "following_id", encodeInt_comparison_exp |> Encode.optional input.following_id ), ( "user", encodeUsers_bool_exp |> Encode.optional input.user ) ]


buildFollows_insert_input : (Follows_insert_inputOptionalFields -> Follows_insert_inputOptionalFields) -> Follows_insert_input
buildFollows_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { following_id = Absent }
    in
    { following_id = optionals.following_id }


type alias Follows_insert_inputOptionalFields =
    { following_id : OptionalArgument Int }


{-| Type for the Follows\_insert\_input input object.
-}
type alias Follows_insert_input =
    { following_id : OptionalArgument Int }


{-| Encode a Follows\_insert\_input into a value that can be used as an argument.
-}
encodeFollows_insert_input : Follows_insert_input -> Value
encodeFollows_insert_input input =
    Encode.maybeObject
        [ ( "following_id", Encode.int |> Encode.optional input.following_id ) ]


buildFollows_obj_rel_insert_input : Follows_obj_rel_insert_inputRequiredFields -> Follows_obj_rel_insert_input
buildFollows_obj_rel_insert_input required =
    { data = required.data }


type alias Follows_obj_rel_insert_inputRequiredFields =
    { data : Follows_insert_input }


{-| Type for the Follows\_obj\_rel\_insert\_input input object.
-}
type alias Follows_obj_rel_insert_input =
    { data : Follows_insert_input }


{-| Encode a Follows\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeFollows_obj_rel_insert_input : Follows_obj_rel_insert_input -> Value
encodeFollows_obj_rel_insert_input input =
    Encode.maybeObject
        [ ( "data", encodeFollows_insert_input input.data |> Just ) ]


buildFollows_order_by : (Follows_order_byOptionalFields -> Follows_order_byOptionalFields) -> Follows_order_by
buildFollows_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { following_id = Absent, user = Absent }
    in
    { following_id = optionals.following_id, user = optionals.user }


type alias Follows_order_byOptionalFields =
    { following_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    }


{-| Type for the Follows\_order\_by input object.
-}
type alias Follows_order_by =
    { following_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    }


{-| Encode a Follows\_order\_by into a value that can be used as an argument.
-}
encodeFollows_order_by : Follows_order_by -> Value
encodeFollows_order_by input =
    Encode.maybeObject
        [ ( "following_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.following_id ), ( "user", encodeUsers_order_by |> Encode.optional input.user ) ]


buildFollows_pk_columns_input : Follows_pk_columns_inputRequiredFields -> Follows_pk_columns_input
buildFollows_pk_columns_input required =
    { id = required.id }


type alias Follows_pk_columns_inputRequiredFields =
    { id : Int }


{-| Type for the Follows\_pk\_columns\_input input object.
-}
type alias Follows_pk_columns_input =
    { id : Int }


{-| Encode a Follows\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeFollows_pk_columns_input : Follows_pk_columns_input -> Value
encodeFollows_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", Encode.int input.id |> Just ) ]


buildInt_comparison_exp : (Int_comparison_expOptionalFields -> Int_comparison_expOptionalFields) -> Int_comparison_exp
buildInt_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Int_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Type for the Int\_comparison\_exp input object.
-}
type alias Int_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Encode a Int\_comparison\_exp into a value that can be used as an argument.
-}
encodeInt_comparison_exp : Int_comparison_exp -> Value
encodeInt_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input.eq_ ), ( "_gt", Encode.int |> Encode.optional input.gt_ ), ( "_gte", Encode.int |> Encode.optional input.gte_ ), ( "_in", (Encode.int |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.int |> Encode.optional input.lt_ ), ( "_lte", Encode.int |> Encode.optional input.lte_ ), ( "_neq", Encode.int |> Encode.optional input.neq_ ), ( "_nin", (Encode.int |> Encode.list) |> Encode.optional input.nin_ ) ]


buildJson_comparison_exp : (Json_comparison_expOptionalFields -> Json_comparison_expOptionalFields) -> Json_comparison_exp
buildJson_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Json_comparison_expOptionalFields =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Json
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Json
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Json
    , in_ : OptionalArgument (List Hasura.ScalarCodecs.Json)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Json
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Json
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Json
    , nin_ : OptionalArgument (List Hasura.ScalarCodecs.Json)
    }


{-| Type for the Json\_comparison\_exp input object.
-}
type alias Json_comparison_exp =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Json
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Json
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Json
    , in_ : OptionalArgument (List Hasura.ScalarCodecs.Json)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Json
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Json
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Json
    , nin_ : OptionalArgument (List Hasura.ScalarCodecs.Json)
    }


{-| Encode a Json\_comparison\_exp into a value that can be used as an argument.
-}
encodeJson_comparison_exp : Json_comparison_exp -> Value
encodeJson_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.optional input.eq_ ), ( "_gt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.optional input.gt_ ), ( "_gte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.optional input.gte_ ), ( "_in", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.optional input.lt_ ), ( "_lte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.optional input.lte_ ), ( "_neq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.optional input.neq_ ), ( "_nin", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecJson) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildLikes_aggregate_order_by : (Likes_aggregate_order_byOptionalFields -> Likes_aggregate_order_byOptionalFields) -> Likes_aggregate_order_by
buildLikes_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Likes_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Likes_avg_order_by
    , count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Likes_max_order_by
    , min : OptionalArgument Likes_min_order_by
    , stddev : OptionalArgument Likes_stddev_order_by
    , stddev_pop : OptionalArgument Likes_stddev_pop_order_by
    , stddev_samp : OptionalArgument Likes_stddev_samp_order_by
    , sum : OptionalArgument Likes_sum_order_by
    , var_pop : OptionalArgument Likes_var_pop_order_by
    , var_samp : OptionalArgument Likes_var_samp_order_by
    , variance : OptionalArgument Likes_variance_order_by
    }


{-| Type for the Likes\_aggregate\_order\_by input object.
-}
type alias Likes_aggregate_order_by =
    { avg : OptionalArgument Likes_avg_order_by
    , count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Likes_max_order_by
    , min : OptionalArgument Likes_min_order_by
    , stddev : OptionalArgument Likes_stddev_order_by
    , stddev_pop : OptionalArgument Likes_stddev_pop_order_by
    , stddev_samp : OptionalArgument Likes_stddev_samp_order_by
    , sum : OptionalArgument Likes_sum_order_by
    , var_pop : OptionalArgument Likes_var_pop_order_by
    , var_samp : OptionalArgument Likes_var_samp_order_by
    , variance : OptionalArgument Likes_variance_order_by
    }


{-| Encode a Likes\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeLikes_aggregate_order_by : Likes_aggregate_order_by -> Value
encodeLikes_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeLikes_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeLikes_max_order_by |> Encode.optional input.max ), ( "min", encodeLikes_min_order_by |> Encode.optional input.min ), ( "stddev", encodeLikes_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeLikes_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeLikes_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeLikes_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeLikes_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeLikes_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeLikes_variance_order_by |> Encode.optional input.variance ) ]


buildLikes_arr_rel_insert_input : Likes_arr_rel_insert_inputRequiredFields -> Likes_arr_rel_insert_input
buildLikes_arr_rel_insert_input required =
    Likes_arr_rel_insert_input { data = required.data }


type alias Likes_arr_rel_insert_inputRequiredFields =
    { data : List Likes_insert_input }


{-| Type alias for the `Likes_arr_rel_insert_input` attributes. Note that this type
needs to use the `Likes_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Likes_arr_rel_insert_inputRaw =
    { data : List Likes_insert_input }


{-| Type for the Likes\_arr\_rel\_insert\_input input object.
-}
type Likes_arr_rel_insert_input
    = Likes_arr_rel_insert_input Likes_arr_rel_insert_inputRaw


{-| Encode a Likes\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeLikes_arr_rel_insert_input : Likes_arr_rel_insert_input -> Value
encodeLikes_arr_rel_insert_input (Likes_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeLikes_insert_input |> Encode.list) input.data |> Just ) ]


buildLikes_avg_order_by : (Likes_avg_order_byOptionalFields -> Likes_avg_order_byOptionalFields) -> Likes_avg_order_by
buildLikes_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { article_id = Absent, user_id = Absent }
    in
    { article_id = optionals.article_id, user_id = optionals.user_id }


type alias Likes_avg_order_byOptionalFields =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Likes\_avg\_order\_by input object.
-}
type alias Likes_avg_order_by =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Likes\_avg\_order\_by into a value that can be used as an argument.
-}
encodeLikes_avg_order_by : Likes_avg_order_by -> Value
encodeLikes_avg_order_by input =
    Encode.maybeObject
        [ ( "article_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.article_id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildLikes_bool_exp : (Likes_bool_expOptionalFields -> Likes_bool_expOptionalFields) -> Likes_bool_exp
buildLikes_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, article = Absent, article_id = Absent, user = Absent, user_id = Absent }
    in
    Likes_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, article = optionals.article, article_id = optionals.article_id, user = optionals.user, user_id = optionals.user_id }


type alias Likes_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Likes_bool_exp))
    , not_ : OptionalArgument Likes_bool_exp
    , or_ : OptionalArgument (List (Maybe Likes_bool_exp))
    , article : OptionalArgument Articles_bool_exp
    , article_id : OptionalArgument Int_comparison_exp
    , user : OptionalArgument Users_bool_exp
    , user_id : OptionalArgument Int_comparison_exp
    }


{-| Type alias for the `Likes_bool_exp` attributes. Note that this type
needs to use the `Likes_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Likes_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Likes_bool_exp))
    , not_ : OptionalArgument Likes_bool_exp
    , or_ : OptionalArgument (List (Maybe Likes_bool_exp))
    , article : OptionalArgument Articles_bool_exp
    , article_id : OptionalArgument Int_comparison_exp
    , user : OptionalArgument Users_bool_exp
    , user_id : OptionalArgument Int_comparison_exp
    }


{-| Type for the Likes\_bool\_exp input object.
-}
type Likes_bool_exp
    = Likes_bool_exp Likes_bool_expRaw


{-| Encode a Likes\_bool\_exp into a value that can be used as an argument.
-}
encodeLikes_bool_exp : Likes_bool_exp -> Value
encodeLikes_bool_exp (Likes_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeLikes_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeLikes_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeLikes_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "article", encodeArticles_bool_exp |> Encode.optional input.article ), ( "article_id", encodeInt_comparison_exp |> Encode.optional input.article_id ), ( "user", encodeUsers_bool_exp |> Encode.optional input.user ), ( "user_id", encodeInt_comparison_exp |> Encode.optional input.user_id ) ]


buildLikes_insert_input : (Likes_insert_inputOptionalFields -> Likes_insert_inputOptionalFields) -> Likes_insert_input
buildLikes_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { article = Absent, article_id = Absent }
    in
    Likes_insert_input { article = optionals.article, article_id = optionals.article_id }


type alias Likes_insert_inputOptionalFields =
    { article : OptionalArgument Articles_obj_rel_insert_input
    , article_id : OptionalArgument Int
    }


{-| Type alias for the `Likes_insert_input` attributes. Note that this type
needs to use the `Likes_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Likes_insert_inputRaw =
    { article : OptionalArgument Articles_obj_rel_insert_input
    , article_id : OptionalArgument Int
    }


{-| Type for the Likes\_insert\_input input object.
-}
type Likes_insert_input
    = Likes_insert_input Likes_insert_inputRaw


{-| Encode a Likes\_insert\_input into a value that can be used as an argument.
-}
encodeLikes_insert_input : Likes_insert_input -> Value
encodeLikes_insert_input (Likes_insert_input input) =
    Encode.maybeObject
        [ ( "article", encodeArticles_obj_rel_insert_input |> Encode.optional input.article ), ( "article_id", Encode.int |> Encode.optional input.article_id ) ]


buildLikes_max_order_by : (Likes_max_order_byOptionalFields -> Likes_max_order_byOptionalFields) -> Likes_max_order_by
buildLikes_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { article_id = Absent, user_id = Absent }
    in
    { article_id = optionals.article_id, user_id = optionals.user_id }


type alias Likes_max_order_byOptionalFields =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Likes\_max\_order\_by input object.
-}
type alias Likes_max_order_by =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Likes\_max\_order\_by into a value that can be used as an argument.
-}
encodeLikes_max_order_by : Likes_max_order_by -> Value
encodeLikes_max_order_by input =
    Encode.maybeObject
        [ ( "article_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.article_id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildLikes_min_order_by : (Likes_min_order_byOptionalFields -> Likes_min_order_byOptionalFields) -> Likes_min_order_by
buildLikes_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { article_id = Absent, user_id = Absent }
    in
    { article_id = optionals.article_id, user_id = optionals.user_id }


type alias Likes_min_order_byOptionalFields =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Likes\_min\_order\_by input object.
-}
type alias Likes_min_order_by =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Likes\_min\_order\_by into a value that can be used as an argument.
-}
encodeLikes_min_order_by : Likes_min_order_by -> Value
encodeLikes_min_order_by input =
    Encode.maybeObject
        [ ( "article_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.article_id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildLikes_obj_rel_insert_input : Likes_obj_rel_insert_inputRequiredFields -> Likes_obj_rel_insert_input
buildLikes_obj_rel_insert_input required =
    Likes_obj_rel_insert_input { data = required.data }


type alias Likes_obj_rel_insert_inputRequiredFields =
    { data : Likes_insert_input }


{-| Type alias for the `Likes_obj_rel_insert_input` attributes. Note that this type
needs to use the `Likes_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Likes_obj_rel_insert_inputRaw =
    { data : Likes_insert_input }


{-| Type for the Likes\_obj\_rel\_insert\_input input object.
-}
type Likes_obj_rel_insert_input
    = Likes_obj_rel_insert_input Likes_obj_rel_insert_inputRaw


{-| Encode a Likes\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeLikes_obj_rel_insert_input : Likes_obj_rel_insert_input -> Value
encodeLikes_obj_rel_insert_input (Likes_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeLikes_insert_input input.data |> Just ) ]


buildLikes_order_by : (Likes_order_byOptionalFields -> Likes_order_byOptionalFields) -> Likes_order_by
buildLikes_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { article = Absent, article_id = Absent, user = Absent, user_id = Absent }
    in
    Likes_order_by { article = optionals.article, article_id = optionals.article_id, user = optionals.user, user_id = optionals.user_id }


type alias Likes_order_byOptionalFields =
    { article : OptionalArgument Articles_order_by
    , article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type alias for the `Likes_order_by` attributes. Note that this type
needs to use the `Likes_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Likes_order_byRaw =
    { article : OptionalArgument Articles_order_by
    , article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Likes\_order\_by input object.
-}
type Likes_order_by
    = Likes_order_by Likes_order_byRaw


{-| Encode a Likes\_order\_by into a value that can be used as an argument.
-}
encodeLikes_order_by : Likes_order_by -> Value
encodeLikes_order_by (Likes_order_by input) =
    Encode.maybeObject
        [ ( "article", encodeArticles_order_by |> Encode.optional input.article ), ( "article_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.article_id ), ( "user", encodeUsers_order_by |> Encode.optional input.user ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildLikes_pk_columns_input : Likes_pk_columns_inputRequiredFields -> Likes_pk_columns_input
buildLikes_pk_columns_input required =
    { id = required.id }


type alias Likes_pk_columns_inputRequiredFields =
    { id : Int }


{-| Type for the Likes\_pk\_columns\_input input object.
-}
type alias Likes_pk_columns_input =
    { id : Int }


{-| Encode a Likes\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeLikes_pk_columns_input : Likes_pk_columns_input -> Value
encodeLikes_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", Encode.int input.id |> Just ) ]


buildLikes_stddev_order_by : (Likes_stddev_order_byOptionalFields -> Likes_stddev_order_byOptionalFields) -> Likes_stddev_order_by
buildLikes_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { article_id = Absent, user_id = Absent }
    in
    { article_id = optionals.article_id, user_id = optionals.user_id }


type alias Likes_stddev_order_byOptionalFields =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Likes\_stddev\_order\_by input object.
-}
type alias Likes_stddev_order_by =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Likes\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeLikes_stddev_order_by : Likes_stddev_order_by -> Value
encodeLikes_stddev_order_by input =
    Encode.maybeObject
        [ ( "article_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.article_id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildLikes_stddev_pop_order_by : (Likes_stddev_pop_order_byOptionalFields -> Likes_stddev_pop_order_byOptionalFields) -> Likes_stddev_pop_order_by
buildLikes_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { article_id = Absent, user_id = Absent }
    in
    { article_id = optionals.article_id, user_id = optionals.user_id }


type alias Likes_stddev_pop_order_byOptionalFields =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Likes\_stddev\_pop\_order\_by input object.
-}
type alias Likes_stddev_pop_order_by =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Likes\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeLikes_stddev_pop_order_by : Likes_stddev_pop_order_by -> Value
encodeLikes_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "article_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.article_id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildLikes_stddev_samp_order_by : (Likes_stddev_samp_order_byOptionalFields -> Likes_stddev_samp_order_byOptionalFields) -> Likes_stddev_samp_order_by
buildLikes_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { article_id = Absent, user_id = Absent }
    in
    { article_id = optionals.article_id, user_id = optionals.user_id }


type alias Likes_stddev_samp_order_byOptionalFields =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Likes\_stddev\_samp\_order\_by input object.
-}
type alias Likes_stddev_samp_order_by =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Likes\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeLikes_stddev_samp_order_by : Likes_stddev_samp_order_by -> Value
encodeLikes_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "article_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.article_id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildLikes_sum_order_by : (Likes_sum_order_byOptionalFields -> Likes_sum_order_byOptionalFields) -> Likes_sum_order_by
buildLikes_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { article_id = Absent, user_id = Absent }
    in
    { article_id = optionals.article_id, user_id = optionals.user_id }


type alias Likes_sum_order_byOptionalFields =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Likes\_sum\_order\_by input object.
-}
type alias Likes_sum_order_by =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Likes\_sum\_order\_by into a value that can be used as an argument.
-}
encodeLikes_sum_order_by : Likes_sum_order_by -> Value
encodeLikes_sum_order_by input =
    Encode.maybeObject
        [ ( "article_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.article_id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildLikes_var_pop_order_by : (Likes_var_pop_order_byOptionalFields -> Likes_var_pop_order_byOptionalFields) -> Likes_var_pop_order_by
buildLikes_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { article_id = Absent, user_id = Absent }
    in
    { article_id = optionals.article_id, user_id = optionals.user_id }


type alias Likes_var_pop_order_byOptionalFields =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Likes\_var\_pop\_order\_by input object.
-}
type alias Likes_var_pop_order_by =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Likes\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeLikes_var_pop_order_by : Likes_var_pop_order_by -> Value
encodeLikes_var_pop_order_by input =
    Encode.maybeObject
        [ ( "article_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.article_id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildLikes_var_samp_order_by : (Likes_var_samp_order_byOptionalFields -> Likes_var_samp_order_byOptionalFields) -> Likes_var_samp_order_by
buildLikes_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { article_id = Absent, user_id = Absent }
    in
    { article_id = optionals.article_id, user_id = optionals.user_id }


type alias Likes_var_samp_order_byOptionalFields =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Likes\_var\_samp\_order\_by input object.
-}
type alias Likes_var_samp_order_by =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Likes\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeLikes_var_samp_order_by : Likes_var_samp_order_by -> Value
encodeLikes_var_samp_order_by input =
    Encode.maybeObject
        [ ( "article_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.article_id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildLikes_variance_order_by : (Likes_variance_order_byOptionalFields -> Likes_variance_order_byOptionalFields) -> Likes_variance_order_by
buildLikes_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { article_id = Absent, user_id = Absent }
    in
    { article_id = optionals.article_id, user_id = optionals.user_id }


type alias Likes_variance_order_byOptionalFields =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Likes\_variance\_order\_by input object.
-}
type alias Likes_variance_order_by =
    { article_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Likes\_variance\_order\_by into a value that can be used as an argument.
-}
encodeLikes_variance_order_by : Likes_variance_order_by -> Value
encodeLikes_variance_order_by input =
    Encode.maybeObject
        [ ( "article_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.article_id ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildString_comparison_exp : (String_comparison_expOptionalFields -> String_comparison_expOptionalFields) -> String_comparison_exp
buildString_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]


buildTags_arr_rel_insert_input : Tags_arr_rel_insert_inputRequiredFields -> Tags_arr_rel_insert_input
buildTags_arr_rel_insert_input required =
    { data = required.data }


type alias Tags_arr_rel_insert_inputRequiredFields =
    { data : List Tags_insert_input }


{-| Type for the Tags\_arr\_rel\_insert\_input input object.
-}
type alias Tags_arr_rel_insert_input =
    { data : List Tags_insert_input }


{-| Encode a Tags\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTags_arr_rel_insert_input : Tags_arr_rel_insert_input -> Value
encodeTags_arr_rel_insert_input input =
    Encode.maybeObject
        [ ( "data", (encodeTags_insert_input |> Encode.list) input.data |> Just ) ]


buildTags_bool_exp : (Tags_bool_expOptionalFields -> Tags_bool_expOptionalFields) -> Tags_bool_exp
buildTags_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, tag = Absent }
    in
    Tags_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, tag = optionals.tag }


type alias Tags_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Tags_bool_exp))
    , not_ : OptionalArgument Tags_bool_exp
    , or_ : OptionalArgument (List (Maybe Tags_bool_exp))
    , tag : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Tags_bool_exp` attributes. Note that this type
needs to use the `Tags_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tags_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Tags_bool_exp))
    , not_ : OptionalArgument Tags_bool_exp
    , or_ : OptionalArgument (List (Maybe Tags_bool_exp))
    , tag : OptionalArgument String_comparison_exp
    }


{-| Type for the Tags\_bool\_exp input object.
-}
type Tags_bool_exp
    = Tags_bool_exp Tags_bool_expRaw


{-| Encode a Tags\_bool\_exp into a value that can be used as an argument.
-}
encodeTags_bool_exp : Tags_bool_exp -> Value
encodeTags_bool_exp (Tags_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeTags_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeTags_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeTags_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "tag", encodeString_comparison_exp |> Encode.optional input.tag ) ]


buildTags_insert_input : (Tags_insert_inputOptionalFields -> Tags_insert_inputOptionalFields) -> Tags_insert_input
buildTags_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { tag = Absent }
    in
    { tag = optionals.tag }


type alias Tags_insert_inputOptionalFields =
    { tag : OptionalArgument String }


{-| Type for the Tags\_insert\_input input object.
-}
type alias Tags_insert_input =
    { tag : OptionalArgument String }


{-| Encode a Tags\_insert\_input into a value that can be used as an argument.
-}
encodeTags_insert_input : Tags_insert_input -> Value
encodeTags_insert_input input =
    Encode.maybeObject
        [ ( "tag", Encode.string |> Encode.optional input.tag ) ]


buildTags_obj_rel_insert_input : Tags_obj_rel_insert_inputRequiredFields -> Tags_obj_rel_insert_input
buildTags_obj_rel_insert_input required =
    { data = required.data }


type alias Tags_obj_rel_insert_inputRequiredFields =
    { data : Tags_insert_input }


{-| Type for the Tags\_obj\_rel\_insert\_input input object.
-}
type alias Tags_obj_rel_insert_input =
    { data : Tags_insert_input }


{-| Encode a Tags\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTags_obj_rel_insert_input : Tags_obj_rel_insert_input -> Value
encodeTags_obj_rel_insert_input input =
    Encode.maybeObject
        [ ( "data", encodeTags_insert_input input.data |> Just ) ]


buildTags_order_by : (Tags_order_byOptionalFields -> Tags_order_byOptionalFields) -> Tags_order_by
buildTags_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { tag = Absent }
    in
    { tag = optionals.tag }


type alias Tags_order_byOptionalFields =
    { tag : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Tags\_order\_by input object.
-}
type alias Tags_order_by =
    { tag : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Tags\_order\_by into a value that can be used as an argument.
-}
encodeTags_order_by : Tags_order_by -> Value
encodeTags_order_by input =
    Encode.maybeObject
        [ ( "tag", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.tag ) ]


buildTags_pk_columns_input : Tags_pk_columns_inputRequiredFields -> Tags_pk_columns_input
buildTags_pk_columns_input required =
    { id = required.id }


type alias Tags_pk_columns_inputRequiredFields =
    { id : Int }


{-| Type for the Tags\_pk\_columns\_input input object.
-}
type alias Tags_pk_columns_input =
    { id : Int }


{-| Encode a Tags\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeTags_pk_columns_input : Tags_pk_columns_input -> Value
encodeTags_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", Encode.int input.id |> Just ) ]


buildTimestamptz_comparison_exp : (Timestamptz_comparison_expOptionalFields -> Timestamptz_comparison_expOptionalFields) -> Timestamptz_comparison_exp
buildTimestamptz_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Timestamptz_comparison_expOptionalFields =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    }


{-| Type for the Timestamptz\_comparison\_exp input object.
-}
type alias Timestamptz_comparison_exp =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    }


{-| Encode a Timestamptz\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamptz_comparison_exp : Timestamptz_comparison_exp -> Value
encodeTimestamptz_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.eq_ ), ( "_gt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gt_ ), ( "_gte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gte_ ), ( "_in", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lt_ ), ( "_lte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lte_ ), ( "_neq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.neq_ ), ( "_nin", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildUsers_bool_exp : (Users_bool_expOptionalFields -> Users_bool_expOptionalFields) -> Users_bool_exp
buildUsers_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, articles = Absent, follows = Absent, id = Absent, profile_image = Absent, username = Absent }
    in
    Users_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, articles = optionals.articles, follows = optionals.follows, id = optionals.id, profile_image = optionals.profile_image, username = optionals.username }


type alias Users_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Users_bool_exp))
    , not_ : OptionalArgument Users_bool_exp
    , or_ : OptionalArgument (List (Maybe Users_bool_exp))
    , articles : OptionalArgument Articles_bool_exp
    , follows : OptionalArgument Follows_bool_exp
    , id : OptionalArgument Int_comparison_exp
    , profile_image : OptionalArgument String_comparison_exp
    , username : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Users_bool_exp` attributes. Note that this type
needs to use the `Users_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Users_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Users_bool_exp))
    , not_ : OptionalArgument Users_bool_exp
    , or_ : OptionalArgument (List (Maybe Users_bool_exp))
    , articles : OptionalArgument Articles_bool_exp
    , follows : OptionalArgument Follows_bool_exp
    , id : OptionalArgument Int_comparison_exp
    , profile_image : OptionalArgument String_comparison_exp
    , username : OptionalArgument String_comparison_exp
    }


{-| Type for the Users\_bool\_exp input object.
-}
type Users_bool_exp
    = Users_bool_exp Users_bool_expRaw


{-| Encode a Users\_bool\_exp into a value that can be used as an argument.
-}
encodeUsers_bool_exp : Users_bool_exp -> Value
encodeUsers_bool_exp (Users_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeUsers_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeUsers_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeUsers_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "articles", encodeArticles_bool_exp |> Encode.optional input.articles ), ( "follows", encodeFollows_bool_exp |> Encode.optional input.follows ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "profile_image", encodeString_comparison_exp |> Encode.optional input.profile_image ), ( "username", encodeString_comparison_exp |> Encode.optional input.username ) ]


buildUsers_order_by : (Users_order_byOptionalFields -> Users_order_byOptionalFields) -> Users_order_by
buildUsers_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, profile_image = Absent, username = Absent }
    in
    { id = optionals.id, profile_image = optionals.profile_image, username = optionals.username }


type alias Users_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , profile_image : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Users\_order\_by input object.
-}
type alias Users_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , profile_image : OptionalArgument Hasura.Enum.Order_by.Order_by
    , username : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Users\_order\_by into a value that can be used as an argument.
-}
encodeUsers_order_by : Users_order_by -> Value
encodeUsers_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "profile_image", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.profile_image ), ( "username", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.username ) ]


buildUsers_pk_columns_input : Users_pk_columns_inputRequiredFields -> Users_pk_columns_input
buildUsers_pk_columns_input required =
    { id = required.id }


type alias Users_pk_columns_inputRequiredFields =
    { id : Int }


{-| Type for the Users\_pk\_columns\_input input object.
-}
type alias Users_pk_columns_input =
    { id : Int }


{-| Encode a Users\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeUsers_pk_columns_input : Users_pk_columns_input -> Value
encodeUsers_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", Encode.int input.id |> Just ) ]
