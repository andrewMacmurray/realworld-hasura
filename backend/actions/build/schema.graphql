schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"Directs the executor to include this field or fragment only when the `if` argument is true"
directive @include(
    "Included when true."
    if: Boolean!
  ) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Directs the executor to skip this field or fragment when the `if`'argument is true."
directive @skip(
    "Skipped when true."
    if: Boolean!
  ) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Marks the field or enum value as deprecated"
directive @deprecated(
    "The reason for the deprecation"
    reason: String = "No longer supported"
  ) on FIELD_DEFINITION | ENUM_VALUE

"Exposes a URL that specifies the behaviour of this scalar."
directive @specifiedBy(
    "The URL that specifies the behaviour of this scalar."
    url: String!
  ) on SCALAR

type TokenResponse {
  bio: String
  email: String!
  follows: [follows]
  profile_image: String
  token: String!
  user_id: Int!
  username: String!
}

type UnlikeResponse {
  article: articles
  article_id: Int
}

"columns and relationships of \"articles\""
type articles {
  about: String!
  "An object relationship"
  author: users!
  author_id: Int!
  "An array relationship"
  comments(
    "distinct select on columns"
    distinct_on: [comments_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [comments_order_by!], 
    "filter the rows returned"
    where: comments_bool_exp
  ): [comments!]!
  "An aggregated array relationship"
  comments_aggregate(
    "distinct select on columns"
    distinct_on: [comments_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [comments_order_by!], 
    "filter the rows returned"
    where: comments_bool_exp
  ): comments_aggregate!
  content: String!
  created_at: timestamptz!
  id: Int!
  "An array relationship"
  likes(
    "distinct select on columns"
    distinct_on: [likes_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [likes_order_by!], 
    "filter the rows returned"
    where: likes_bool_exp
  ): [likes!]!
  "An aggregated array relationship"
  likes_aggregate(
    "distinct select on columns"
    distinct_on: [likes_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [likes_order_by!], 
    "filter the rows returned"
    where: likes_bool_exp
  ): likes_aggregate!
  "An array relationship"
  tags(
    "distinct select on columns"
    distinct_on: [tags_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [tags_order_by!], 
    "filter the rows returned"
    where: tags_bool_exp
  ): [tags!]!
  "An aggregated array relationship"
  tags_aggregate(
    "distinct select on columns"
    distinct_on: [tags_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [tags_order_by!], 
    "filter the rows returned"
    where: tags_bool_exp
  ): tags_aggregate!
  title: String!
}

"aggregated selection of \"articles\""
type articles_aggregate {
  aggregate: articles_aggregate_fields
  nodes: [articles!]!
}

"aggregate fields of \"articles\""
type articles_aggregate_fields {
  avg: articles_avg_fields
  count(columns: [articles_select_column!], distinct: Boolean): Int
  max: articles_max_fields
  min: articles_min_fields
  stddev: articles_stddev_fields
  stddev_pop: articles_stddev_pop_fields
  stddev_samp: articles_stddev_samp_fields
  sum: articles_sum_fields
  var_pop: articles_var_pop_fields
  var_samp: articles_var_samp_fields
  variance: articles_variance_fields
}

"aggregate avg on columns"
type articles_avg_fields {
  author_id: Float
  id: Float
}

"aggregate max on columns"
type articles_max_fields {
  about: String
  author_id: Int
  content: String
  created_at: timestamptz
  id: Int
  title: String
}

"aggregate min on columns"
type articles_min_fields {
  about: String
  author_id: Int
  content: String
  created_at: timestamptz
  id: Int
  title: String
}

"response of any mutation on the table \"articles\""
type articles_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [articles!]!
}

"aggregate stddev on columns"
type articles_stddev_fields {
  author_id: Float
  id: Float
}

"aggregate stddev_pop on columns"
type articles_stddev_pop_fields {
  author_id: Float
  id: Float
}

"aggregate stddev_samp on columns"
type articles_stddev_samp_fields {
  author_id: Float
  id: Float
}

"aggregate sum on columns"
type articles_sum_fields {
  author_id: Int
  id: Int
}

"aggregate var_pop on columns"
type articles_var_pop_fields {
  author_id: Float
  id: Float
}

"aggregate var_samp on columns"
type articles_var_samp_fields {
  author_id: Float
  id: Float
}

"aggregate variance on columns"
type articles_variance_fields {
  author_id: Float
  id: Float
}

"columns and relationships of \"comments\""
type comments {
  "An object relationship"
  article: articles!
  article_id: Int!
  comment: String!
  created_at: timestamptz!
  id: Int!
  "An object relationship"
  user: users!
  user_id: Int!
}

"aggregated selection of \"comments\""
type comments_aggregate {
  aggregate: comments_aggregate_fields
  nodes: [comments!]!
}

"aggregate fields of \"comments\""
type comments_aggregate_fields {
  avg: comments_avg_fields
  count(columns: [comments_select_column!], distinct: Boolean): Int
  max: comments_max_fields
  min: comments_min_fields
  stddev: comments_stddev_fields
  stddev_pop: comments_stddev_pop_fields
  stddev_samp: comments_stddev_samp_fields
  sum: comments_sum_fields
  var_pop: comments_var_pop_fields
  var_samp: comments_var_samp_fields
  variance: comments_variance_fields
}

"aggregate avg on columns"
type comments_avg_fields {
  article_id: Float
  id: Float
  user_id: Float
}

"aggregate max on columns"
type comments_max_fields {
  article_id: Int
  comment: String
  created_at: timestamptz
  id: Int
  user_id: Int
}

"aggregate min on columns"
type comments_min_fields {
  article_id: Int
  comment: String
  created_at: timestamptz
  id: Int
  user_id: Int
}

"response of any mutation on the table \"comments\""
type comments_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [comments!]!
}

"aggregate stddev on columns"
type comments_stddev_fields {
  article_id: Float
  id: Float
  user_id: Float
}

"aggregate stddev_pop on columns"
type comments_stddev_pop_fields {
  article_id: Float
  id: Float
  user_id: Float
}

"aggregate stddev_samp on columns"
type comments_stddev_samp_fields {
  article_id: Float
  id: Float
  user_id: Float
}

"aggregate sum on columns"
type comments_sum_fields {
  article_id: Int
  id: Int
  user_id: Int
}

"aggregate var_pop on columns"
type comments_var_pop_fields {
  article_id: Float
  id: Float
  user_id: Float
}

"aggregate var_samp on columns"
type comments_var_samp_fields {
  article_id: Float
  id: Float
  user_id: Float
}

"aggregate variance on columns"
type comments_variance_fields {
  article_id: Float
  id: Float
  user_id: Float
}

"columns and relationships of \"follows\""
type follows {
  following_id: Int!
  id: Int!
  "An object relationship"
  user: users!
  user_id: Int!
}

"aggregated selection of \"follows\""
type follows_aggregate {
  aggregate: follows_aggregate_fields
  nodes: [follows!]!
}

"aggregate fields of \"follows\""
type follows_aggregate_fields {
  avg: follows_avg_fields
  count(columns: [follows_select_column!], distinct: Boolean): Int
  max: follows_max_fields
  min: follows_min_fields
  stddev: follows_stddev_fields
  stddev_pop: follows_stddev_pop_fields
  stddev_samp: follows_stddev_samp_fields
  sum: follows_sum_fields
  var_pop: follows_var_pop_fields
  var_samp: follows_var_samp_fields
  variance: follows_variance_fields
}

"aggregate avg on columns"
type follows_avg_fields {
  following_id: Float
  id: Float
  user_id: Float
}

"aggregate max on columns"
type follows_max_fields {
  following_id: Int
  id: Int
  user_id: Int
}

"aggregate min on columns"
type follows_min_fields {
  following_id: Int
  id: Int
  user_id: Int
}

"response of any mutation on the table \"follows\""
type follows_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [follows!]!
}

"aggregate stddev on columns"
type follows_stddev_fields {
  following_id: Float
  id: Float
  user_id: Float
}

"aggregate stddev_pop on columns"
type follows_stddev_pop_fields {
  following_id: Float
  id: Float
  user_id: Float
}

"aggregate stddev_samp on columns"
type follows_stddev_samp_fields {
  following_id: Float
  id: Float
  user_id: Float
}

"aggregate sum on columns"
type follows_sum_fields {
  following_id: Int
  id: Int
  user_id: Int
}

"aggregate var_pop on columns"
type follows_var_pop_fields {
  following_id: Float
  id: Float
  user_id: Float
}

"aggregate var_samp on columns"
type follows_var_samp_fields {
  following_id: Float
  id: Float
  user_id: Float
}

"aggregate variance on columns"
type follows_variance_fields {
  following_id: Float
  id: Float
  user_id: Float
}

"columns and relationships of \"likes\""
type likes {
  "An object relationship"
  article: articles!
  article_id: Int!
  id: Int!
  "An object relationship"
  user: users!
  user_id: Int!
}

"aggregated selection of \"likes\""
type likes_aggregate {
  aggregate: likes_aggregate_fields
  nodes: [likes!]!
}

"aggregate fields of \"likes\""
type likes_aggregate_fields {
  avg: likes_avg_fields
  count(columns: [likes_select_column!], distinct: Boolean): Int
  max: likes_max_fields
  min: likes_min_fields
  stddev: likes_stddev_fields
  stddev_pop: likes_stddev_pop_fields
  stddev_samp: likes_stddev_samp_fields
  sum: likes_sum_fields
  var_pop: likes_var_pop_fields
  var_samp: likes_var_samp_fields
  variance: likes_variance_fields
}

"aggregate avg on columns"
type likes_avg_fields {
  article_id: Float
  id: Float
  user_id: Float
}

"aggregate max on columns"
type likes_max_fields {
  article_id: Int
  id: Int
  user_id: Int
}

"aggregate min on columns"
type likes_min_fields {
  article_id: Int
  id: Int
  user_id: Int
}

"response of any mutation on the table \"likes\""
type likes_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [likes!]!
}

"aggregate stddev on columns"
type likes_stddev_fields {
  article_id: Float
  id: Float
  user_id: Float
}

"aggregate stddev_pop on columns"
type likes_stddev_pop_fields {
  article_id: Float
  id: Float
  user_id: Float
}

"aggregate stddev_samp on columns"
type likes_stddev_samp_fields {
  article_id: Float
  id: Float
  user_id: Float
}

"aggregate sum on columns"
type likes_sum_fields {
  article_id: Int
  id: Int
  user_id: Int
}

"aggregate var_pop on columns"
type likes_var_pop_fields {
  article_id: Float
  id: Float
  user_id: Float
}

"aggregate var_samp on columns"
type likes_var_samp_fields {
  article_id: Float
  id: Float
  user_id: Float
}

"aggregate variance on columns"
type likes_variance_fields {
  article_id: Float
  id: Float
  user_id: Float
}

"mutation root"
type mutation_root {
  "insert a single row into the table: \"users\""
  create_user(
    "the row to be inserted"
    object: users_insert_input!, 
    "on conflict condition"
    on_conflict: users_on_conflict
  ): users
  "delete single row from the table: \"articles\""
  delete_article(id: Int!): articles
  "delete data from the table: \"articles\""
  delete_articles(
    "filter the rows which have to be deleted"
    where: articles_bool_exp!
  ): articles_mutation_response
  "delete single row from the table: \"comments\""
  delete_comment(id: Int!): comments
  "delete data from the table: \"comments\""
  delete_comments(
    "filter the rows which have to be deleted"
    where: comments_bool_exp!
  ): comments_mutation_response
  "delete single row from the table: \"follows\""
  delete_follows_by_pk(id: Int!): follows
  "delete data from the table: \"likes\""
  delete_likes(
    "filter the rows which have to be deleted"
    where: likes_bool_exp!
  ): likes_mutation_response
  "delete single row from the table: \"likes\""
  delete_likes_by_pk(id: Int!): likes
  "delete data from the table: \"profile\""
  delete_profile(
    "filter the rows which have to be deleted"
    where: profile_bool_exp!
  ): profile_mutation_response
  "delete data from the table: \"tags\""
  delete_tags(
    "filter the rows which have to be deleted"
    where: tags_bool_exp!
  ): tags_mutation_response
  "delete single row from the table: \"tags\""
  delete_tags_by_pk(id: Int!): tags
  "delete data from the table: \"users\""
  delete_users(
    "filter the rows which have to be deleted"
    where: users_bool_exp!
  ): users_mutation_response
  "delete single row from the table: \"users\""
  delete_users_by_pk(id: Int!): users
  "update single row of the table: \"articles\""
  edit_article(
    "increments the integer columns with given value of the filtered values"
    _inc: articles_inc_input, 
    "sets the columns of the filtered rows to the given values"
    _set: articles_set_input, 
    pk_columns: articles_pk_columns_input!
  ): articles
  "insert a single row into the table: \"follows\""
  follow_author(
    "the row to be inserted"
    object: follows_insert_input!, 
    "on conflict condition"
    on_conflict: follows_on_conflict
  ): follows
  "insert data into the table: \"follows\""
  follow_authors(
    "the rows to be inserted"
    objects: [follows_insert_input!]!, 
    "on conflict condition"
    on_conflict: follows_on_conflict
  ): follows_mutation_response
  "insert data into the table: \"comments\""
  insert_comments(
    "the rows to be inserted"
    objects: [comments_insert_input!]!, 
    "on conflict condition"
    on_conflict: comments_on_conflict
  ): comments_mutation_response
  "insert data into the table: \"profile\""
  insert_profile(
    "the rows to be inserted"
    objects: [profile_insert_input!]!
  ): profile_mutation_response
  "insert a single row into the table: \"profile\""
  insert_profile_one(
    "the row to be inserted"
    object: profile_insert_input!
  ): profile
  "insert a single row into the table: \"tags\""
  insert_tag(
    "the row to be inserted"
    object: tags_insert_input!, 
    "on conflict condition"
    on_conflict: tags_on_conflict
  ): tags
  "insert data into the table: \"tags\""
  insert_tags(
    "the rows to be inserted"
    objects: [tags_insert_input!]!, 
    "on conflict condition"
    on_conflict: tags_on_conflict
  ): tags_mutation_response
  "insert data into the table: \"users\""
  insert_users(
    "the rows to be inserted"
    objects: [users_insert_input!]!, 
    "on conflict condition"
    on_conflict: users_on_conflict
  ): users_mutation_response
  "insert a single row into the table: \"likes\""
  like_article(
    "the row to be inserted"
    object: likes_insert_input!, 
    "on conflict condition"
    on_conflict: likes_on_conflict
  ): likes
  "insert data into the table: \"likes\""
  like_articles(
    "the rows to be inserted"
    objects: [likes_insert_input!]!, 
    "on conflict condition"
    on_conflict: likes_on_conflict
  ): likes_mutation_response
  "perform the action: \"login\""
  login(password: String!, username: String!): TokenResponse!
  "insert a single row into the table: \"comments\""
  post_comment(
    "the row to be inserted"
    object: comments_insert_input!, 
    "on conflict condition"
    on_conflict: comments_on_conflict
  ): comments
  "insert a single row into the table: \"articles\""
  publish_article(
    "the row to be inserted"
    object: articles_insert_input!, 
    "on conflict condition"
    on_conflict: articles_on_conflict
  ): articles
  "insert data into the table: \"articles\""
  publish_articles(
    "the rows to be inserted"
    objects: [articles_insert_input!]!, 
    "on conflict condition"
    on_conflict: articles_on_conflict
  ): articles_mutation_response
  "perform the action: \"signup\""
  signup(email: String!, password: String!, username: String!): TokenResponse!
  "delete data from the table: \"follows\""
  unfollow_authors(
    "filter the rows which have to be deleted"
    where: follows_bool_exp!
  ): follows_mutation_response
  "perform the action: \"unlike_article\""
  unlike_article(article_id: Int!): UnlikeResponse!
  "update data of the table: \"articles\""
  update_articles(
    "increments the integer columns with given value of the filtered values"
    _inc: articles_inc_input, 
    "sets the columns of the filtered rows to the given values"
    _set: articles_set_input, 
    "filter the rows which have to be updated"
    where: articles_bool_exp!
  ): articles_mutation_response
  "update single row of the table: \"comments\""
  update_comment(
    "increments the integer columns with given value of the filtered values"
    _inc: comments_inc_input, 
    "sets the columns of the filtered rows to the given values"
    _set: comments_set_input, 
    pk_columns: comments_pk_columns_input!
  ): comments
  "update data of the table: \"comments\""
  update_comments(
    "increments the integer columns with given value of the filtered values"
    _inc: comments_inc_input, 
    "sets the columns of the filtered rows to the given values"
    _set: comments_set_input, 
    "filter the rows which have to be updated"
    where: comments_bool_exp!
  ): comments_mutation_response
  "update data of the table: \"follows\""
  update_follows(
    "increments the integer columns with given value of the filtered values"
    _inc: follows_inc_input, 
    "sets the columns of the filtered rows to the given values"
    _set: follows_set_input, 
    "filter the rows which have to be updated"
    where: follows_bool_exp!
  ): follows_mutation_response
  "update single row of the table: \"follows\""
  update_follows_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: follows_inc_input, 
    "sets the columns of the filtered rows to the given values"
    _set: follows_set_input, 
    pk_columns: follows_pk_columns_input!
  ): follows
  "update data of the table: \"likes\""
  update_likes(
    "increments the integer columns with given value of the filtered values"
    _inc: likes_inc_input, 
    "sets the columns of the filtered rows to the given values"
    _set: likes_set_input, 
    "filter the rows which have to be updated"
    where: likes_bool_exp!
  ): likes_mutation_response
  "update single row of the table: \"likes\""
  update_likes_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: likes_inc_input, 
    "sets the columns of the filtered rows to the given values"
    _set: likes_set_input, 
    pk_columns: likes_pk_columns_input!
  ): likes
  "update data of the table: \"profile\""
  update_profile(
    "increments the integer columns with given value of the filtered values"
    _inc: profile_inc_input, 
    "sets the columns of the filtered rows to the given values"
    _set: profile_set_input, 
    "filter the rows which have to be updated"
    where: profile_bool_exp!
  ): profile_mutation_response
  "update data of the table: \"tags\""
  update_tags(
    "increments the integer columns with given value of the filtered values"
    _inc: tags_inc_input, 
    "sets the columns of the filtered rows to the given values"
    _set: tags_set_input, 
    "filter the rows which have to be updated"
    where: tags_bool_exp!
  ): tags_mutation_response
  "update single row of the table: \"tags\""
  update_tags_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: tags_inc_input, 
    "sets the columns of the filtered rows to the given values"
    _set: tags_set_input, 
    pk_columns: tags_pk_columns_input!
  ): tags
  "update single row of the table: \"users\""
  update_user(
    "increments the integer columns with given value of the filtered values"
    _inc: users_inc_input, 
    "sets the columns of the filtered rows to the given values"
    _set: users_set_input, 
    pk_columns: users_pk_columns_input!
  ): users
  "update data of the table: \"users\""
  update_users(
    "increments the integer columns with given value of the filtered values"
    _inc: users_inc_input, 
    "sets the columns of the filtered rows to the given values"
    _set: users_set_input, 
    "filter the rows which have to be updated"
    where: users_bool_exp!
  ): users_mutation_response
}

"columns and relationships of \"profile\""
type profile {
  bio: String
  email: String
  "An array relationship"
  follows(
    "distinct select on columns"
    distinct_on: [follows_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [follows_order_by!], 
    "filter the rows returned"
    where: follows_bool_exp
  ): [follows!]!
  "An aggregated array relationship"
  follows_aggregate(
    "distinct select on columns"
    distinct_on: [follows_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [follows_order_by!], 
    "filter the rows returned"
    where: follows_bool_exp
  ): follows_aggregate!
  profile_image: String
  user_id: Int
  username: String
}

"aggregated selection of \"profile\""
type profile_aggregate {
  aggregate: profile_aggregate_fields
  nodes: [profile!]!
}

"aggregate fields of \"profile\""
type profile_aggregate_fields {
  avg: profile_avg_fields
  count(columns: [profile_select_column!], distinct: Boolean): Int
  max: profile_max_fields
  min: profile_min_fields
  stddev: profile_stddev_fields
  stddev_pop: profile_stddev_pop_fields
  stddev_samp: profile_stddev_samp_fields
  sum: profile_sum_fields
  var_pop: profile_var_pop_fields
  var_samp: profile_var_samp_fields
  variance: profile_variance_fields
}

"aggregate avg on columns"
type profile_avg_fields {
  user_id: Float
}

"aggregate max on columns"
type profile_max_fields {
  bio: String
  email: String
  profile_image: String
  user_id: Int
  username: String
}

"aggregate min on columns"
type profile_min_fields {
  bio: String
  email: String
  profile_image: String
  user_id: Int
  username: String
}

"response of any mutation on the table \"profile\""
type profile_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [profile!]!
}

"aggregate stddev on columns"
type profile_stddev_fields {
  user_id: Float
}

"aggregate stddev_pop on columns"
type profile_stddev_pop_fields {
  user_id: Float
}

"aggregate stddev_samp on columns"
type profile_stddev_samp_fields {
  user_id: Float
}

"aggregate sum on columns"
type profile_sum_fields {
  user_id: Int
}

"aggregate var_pop on columns"
type profile_var_pop_fields {
  user_id: Float
}

"aggregate var_samp on columns"
type profile_var_samp_fields {
  user_id: Float
}

"aggregate variance on columns"
type profile_variance_fields {
  user_id: Float
}

"query root"
type query_root {
  "fetch data from the table: \"articles\" using primary key columns"
  article(id: Int!): articles
  "fetch data from the table: \"articles\""
  articles(
    "distinct select on columns"
    distinct_on: [articles_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [articles_order_by!], 
    "filter the rows returned"
    where: articles_bool_exp
  ): [articles!]!
  "fetch aggregated fields from the table: \"articles\""
  articles_aggregate(
    "distinct select on columns"
    distinct_on: [articles_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [articles_order_by!], 
    "filter the rows returned"
    where: articles_bool_exp
  ): articles_aggregate!
  "fetch data from the table: \"comments\""
  comments(
    "distinct select on columns"
    distinct_on: [comments_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [comments_order_by!], 
    "filter the rows returned"
    where: comments_bool_exp
  ): [comments!]!
  "fetch aggregated fields from the table: \"comments\""
  comments_aggregate(
    "distinct select on columns"
    distinct_on: [comments_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [comments_order_by!], 
    "filter the rows returned"
    where: comments_bool_exp
  ): comments_aggregate!
  "fetch data from the table: \"comments\" using primary key columns"
  comments_by_pk(id: Int!): comments
  "fetch data from the table: \"follows\""
  follows(
    "distinct select on columns"
    distinct_on: [follows_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [follows_order_by!], 
    "filter the rows returned"
    where: follows_bool_exp
  ): [follows!]!
  "fetch aggregated fields from the table: \"follows\""
  follows_aggregate(
    "distinct select on columns"
    distinct_on: [follows_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [follows_order_by!], 
    "filter the rows returned"
    where: follows_bool_exp
  ): follows_aggregate!
  "fetch data from the table: \"follows\" using primary key columns"
  follows_by_pk(id: Int!): follows
  "fetch data from the table: \"likes\""
  likes(
    "distinct select on columns"
    distinct_on: [likes_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [likes_order_by!], 
    "filter the rows returned"
    where: likes_bool_exp
  ): [likes!]!
  "fetch aggregated fields from the table: \"likes\""
  likes_aggregate(
    "distinct select on columns"
    distinct_on: [likes_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [likes_order_by!], 
    "filter the rows returned"
    where: likes_bool_exp
  ): likes_aggregate!
  "fetch data from the table: \"likes\" using primary key columns"
  likes_by_pk(id: Int!): likes
  "fetch data from the table: \"profile\""
  profile(
    "distinct select on columns"
    distinct_on: [profile_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [profile_order_by!], 
    "filter the rows returned"
    where: profile_bool_exp
  ): [profile!]!
  "fetch aggregated fields from the table: \"profile\""
  profile_aggregate(
    "distinct select on columns"
    distinct_on: [profile_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [profile_order_by!], 
    "filter the rows returned"
    where: profile_bool_exp
  ): profile_aggregate!
  "fetch data from the table: \"tags\" using primary key columns"
  tag(id: Int!): tags
  "fetch data from the table: \"tags\""
  tags(
    "distinct select on columns"
    distinct_on: [tags_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [tags_order_by!], 
    "filter the rows returned"
    where: tags_bool_exp
  ): [tags!]!
  "fetch aggregated fields from the table: \"tags\""
  tags_summary(
    "distinct select on columns"
    distinct_on: [tags_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [tags_order_by!], 
    "filter the rows returned"
    where: tags_bool_exp
  ): tags_aggregate!
  "fetch data from the table: \"users\" using primary key columns"
  user(id: Int!): users
  "fetch data from the table: \"users\""
  users(
    "distinct select on columns"
    distinct_on: [users_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [users_order_by!], 
    "filter the rows returned"
    where: users_bool_exp
  ): [users!]!
  "fetch aggregated fields from the table: \"users\""
  users_aggregate(
    "distinct select on columns"
    distinct_on: [users_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [users_order_by!], 
    "filter the rows returned"
    where: users_bool_exp
  ): users_aggregate!
}

"subscription root"
type subscription_root {
  "fetch data from the table: \"articles\" using primary key columns"
  article(id: Int!): articles
  "fetch data from the table: \"articles\""
  articles(
    "distinct select on columns"
    distinct_on: [articles_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [articles_order_by!], 
    "filter the rows returned"
    where: articles_bool_exp
  ): [articles!]!
  "fetch aggregated fields from the table: \"articles\""
  articles_aggregate(
    "distinct select on columns"
    distinct_on: [articles_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [articles_order_by!], 
    "filter the rows returned"
    where: articles_bool_exp
  ): articles_aggregate!
  "fetch data from the table: \"comments\""
  comments(
    "distinct select on columns"
    distinct_on: [comments_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [comments_order_by!], 
    "filter the rows returned"
    where: comments_bool_exp
  ): [comments!]!
  "fetch aggregated fields from the table: \"comments\""
  comments_aggregate(
    "distinct select on columns"
    distinct_on: [comments_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [comments_order_by!], 
    "filter the rows returned"
    where: comments_bool_exp
  ): comments_aggregate!
  "fetch data from the table: \"comments\" using primary key columns"
  comments_by_pk(id: Int!): comments
  "fetch data from the table: \"follows\""
  follows(
    "distinct select on columns"
    distinct_on: [follows_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [follows_order_by!], 
    "filter the rows returned"
    where: follows_bool_exp
  ): [follows!]!
  "fetch aggregated fields from the table: \"follows\""
  follows_aggregate(
    "distinct select on columns"
    distinct_on: [follows_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [follows_order_by!], 
    "filter the rows returned"
    where: follows_bool_exp
  ): follows_aggregate!
  "fetch data from the table: \"follows\" using primary key columns"
  follows_by_pk(id: Int!): follows
  "fetch data from the table: \"likes\""
  likes(
    "distinct select on columns"
    distinct_on: [likes_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [likes_order_by!], 
    "filter the rows returned"
    where: likes_bool_exp
  ): [likes!]!
  "fetch aggregated fields from the table: \"likes\""
  likes_aggregate(
    "distinct select on columns"
    distinct_on: [likes_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [likes_order_by!], 
    "filter the rows returned"
    where: likes_bool_exp
  ): likes_aggregate!
  "fetch data from the table: \"likes\" using primary key columns"
  likes_by_pk(id: Int!): likes
  "fetch data from the table: \"profile\""
  profile(
    "distinct select on columns"
    distinct_on: [profile_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [profile_order_by!], 
    "filter the rows returned"
    where: profile_bool_exp
  ): [profile!]!
  "fetch aggregated fields from the table: \"profile\""
  profile_aggregate(
    "distinct select on columns"
    distinct_on: [profile_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [profile_order_by!], 
    "filter the rows returned"
    where: profile_bool_exp
  ): profile_aggregate!
  "fetch data from the table: \"tags\" using primary key columns"
  tag(id: Int!): tags
  "fetch data from the table: \"tags\""
  tags(
    "distinct select on columns"
    distinct_on: [tags_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [tags_order_by!], 
    "filter the rows returned"
    where: tags_bool_exp
  ): [tags!]!
  "fetch aggregated fields from the table: \"tags\""
  tags_summary(
    "distinct select on columns"
    distinct_on: [tags_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [tags_order_by!], 
    "filter the rows returned"
    where: tags_bool_exp
  ): tags_aggregate!
  "fetch data from the table: \"users\" using primary key columns"
  user(id: Int!): users
  "fetch data from the table: \"users\""
  users(
    "distinct select on columns"
    distinct_on: [users_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [users_order_by!], 
    "filter the rows returned"
    where: users_bool_exp
  ): [users!]!
  "fetch aggregated fields from the table: \"users\""
  users_aggregate(
    "distinct select on columns"
    distinct_on: [users_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [users_order_by!], 
    "filter the rows returned"
    where: users_bool_exp
  ): users_aggregate!
}

"columns and relationships of \"tags\""
type tags {
  "An object relationship"
  article: articles!
  article_id: Int!
  "A computed field, executes function \"tag_count\""
  count: Int
  id: Int!
  tag: String!
}

"aggregated selection of \"tags\""
type tags_aggregate {
  aggregate: tags_aggregate_fields
  nodes: [tags!]!
}

"aggregate fields of \"tags\""
type tags_aggregate_fields {
  avg: tags_avg_fields
  count(columns: [tags_select_column!], distinct: Boolean): Int
  max: tags_max_fields
  min: tags_min_fields
  stddev: tags_stddev_fields
  stddev_pop: tags_stddev_pop_fields
  stddev_samp: tags_stddev_samp_fields
  sum: tags_sum_fields
  var_pop: tags_var_pop_fields
  var_samp: tags_var_samp_fields
  variance: tags_variance_fields
}

"aggregate avg on columns"
type tags_avg_fields {
  article_id: Float
  id: Float
}

"aggregate max on columns"
type tags_max_fields {
  article_id: Int
  id: Int
  tag: String
}

"aggregate min on columns"
type tags_min_fields {
  article_id: Int
  id: Int
  tag: String
}

"response of any mutation on the table \"tags\""
type tags_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [tags!]!
}

"aggregate stddev on columns"
type tags_stddev_fields {
  article_id: Float
  id: Float
}

"aggregate stddev_pop on columns"
type tags_stddev_pop_fields {
  article_id: Float
  id: Float
}

"aggregate stddev_samp on columns"
type tags_stddev_samp_fields {
  article_id: Float
  id: Float
}

"aggregate sum on columns"
type tags_sum_fields {
  article_id: Int
  id: Int
}

"aggregate var_pop on columns"
type tags_var_pop_fields {
  article_id: Float
  id: Float
}

"aggregate var_samp on columns"
type tags_var_samp_fields {
  article_id: Float
  id: Float
}

"aggregate variance on columns"
type tags_variance_fields {
  article_id: Float
  id: Float
}

"columns and relationships of \"users\""
type users {
  "An array relationship"
  articles(
    "distinct select on columns"
    distinct_on: [articles_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [articles_order_by!], 
    "filter the rows returned"
    where: articles_bool_exp
  ): [articles!]!
  "An aggregated array relationship"
  articles_aggregate(
    "distinct select on columns"
    distinct_on: [articles_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [articles_order_by!], 
    "filter the rows returned"
    where: articles_bool_exp
  ): articles_aggregate!
  bio: String
  email: String!
  "An array relationship"
  follows(
    "distinct select on columns"
    distinct_on: [follows_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [follows_order_by!], 
    "filter the rows returned"
    where: follows_bool_exp
  ): [follows!]!
  "An aggregated array relationship"
  follows_aggregate(
    "distinct select on columns"
    distinct_on: [follows_select_column!], 
    "limit the number of rows returned"
    limit: Int, 
    "skip the first n rows. Use only with order_by"
    offset: Int, 
    "sort the rows by one or more columns"
    order_by: [follows_order_by!], 
    "filter the rows returned"
    where: follows_bool_exp
  ): follows_aggregate!
  id: Int!
  password_hash: String!
  profile_image: String
  username: String!
}

"aggregated selection of \"users\""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"aggregate fields of \"users\""
type users_aggregate_fields {
  avg: users_avg_fields
  count(columns: [users_select_column!], distinct: Boolean): Int
  max: users_max_fields
  min: users_min_fields
  stddev: users_stddev_fields
  stddev_pop: users_stddev_pop_fields
  stddev_samp: users_stddev_samp_fields
  sum: users_sum_fields
  var_pop: users_var_pop_fields
  var_samp: users_var_samp_fields
  variance: users_variance_fields
}

"aggregate avg on columns"
type users_avg_fields {
  id: Float
}

"aggregate max on columns"
type users_max_fields {
  bio: String
  email: String
  id: Int
  password_hash: String
  profile_image: String
  username: String
}

"aggregate min on columns"
type users_min_fields {
  bio: String
  email: String
  id: Int
  password_hash: String
  profile_image: String
  username: String
}

"response of any mutation on the table \"users\""
type users_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [users!]!
}

"aggregate stddev on columns"
type users_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type users_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type users_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type users_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type users_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type users_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type users_variance_fields {
  id: Float
}

"unique or primary key constraints on table \"articles\""
enum articles_constraint {
  articles_pkey
}

"select columns of table \"articles\""
enum articles_select_column {
  about
  author_id
  content
  created_at
  id
  title
}

"update columns of table \"articles\""
enum articles_update_column {
  about
  author_id
  content
  created_at
  id
  title
}

"unique or primary key constraints on table \"comments\""
enum comments_constraint {
  comments_pkey
}

"select columns of table \"comments\""
enum comments_select_column {
  article_id
  comment
  created_at
  id
  user_id
}

"update columns of table \"comments\""
enum comments_update_column {
  article_id
  comment
  created_at
  id
  user_id
}

"unique or primary key constraints on table \"follows\""
enum follows_constraint {
  follows_pkey
  follows_user_id_following_key
}

"select columns of table \"follows\""
enum follows_select_column {
  following_id
  id
  user_id
}

"update columns of table \"follows\""
enum follows_update_column {
  following_id
  id
  user_id
}

"unique or primary key constraints on table \"likes\""
enum likes_constraint {
  favourites_pkey
  likes_user_id_article_id_key
}

"select columns of table \"likes\""
enum likes_select_column {
  article_id
  id
  user_id
}

"update columns of table \"likes\""
enum likes_update_column {
  article_id
  id
  user_id
}

"column ordering options"
enum order_by {
  asc
  asc_nulls_first
  asc_nulls_last
  desc
  desc_nulls_first
  desc_nulls_last
}

"select columns of table \"profile\""
enum profile_select_column {
  bio
  email
  profile_image
  user_id
  username
}

"unique or primary key constraints on table \"tags\""
enum tags_constraint {
  tags_article_id_tag_key
  tags_pkey
}

"select columns of table \"tags\""
enum tags_select_column {
  article_id
  id
  tag
}

"update columns of table \"tags\""
enum tags_update_column {
  article_id
  id
  tag
}

"unique or primary key constraints on table \"users\""
enum users_constraint {
  users_pkey
  users_username_key
}

"select columns of table \"users\""
enum users_select_column {
  bio
  email
  id
  password_hash
  profile_image
  username
}

"update columns of table \"users\""
enum users_update_column {
  bio
  email
  id
  password_hash
  profile_image
  username
}

"json"
scalar json

"timestamptz"
scalar timestamptz

"uuid"
scalar uuid

"expression to compare columns of type Int. All fields are combined with logical 'AND'."
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"expression to compare columns of type String. All fields are combined with logical 'AND'."
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"order by aggregate values of table \"articles\""
input articles_aggregate_order_by {
  avg: articles_avg_order_by
  count: order_by
  max: articles_max_order_by
  min: articles_min_order_by
  stddev: articles_stddev_order_by
  stddev_pop: articles_stddev_pop_order_by
  stddev_samp: articles_stddev_samp_order_by
  sum: articles_sum_order_by
  var_pop: articles_var_pop_order_by
  var_samp: articles_var_samp_order_by
  variance: articles_variance_order_by
}

"input type for inserting array relation for remote table \"articles\""
input articles_arr_rel_insert_input {
  data: [articles_insert_input!]!
  on_conflict: articles_on_conflict
}

"order by avg() on columns of table \"articles\""
input articles_avg_order_by {
  author_id: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"articles\". All fields are combined with a logical 'AND'."
input articles_bool_exp {
  _and: [articles_bool_exp]
  _not: articles_bool_exp
  _or: [articles_bool_exp]
  about: String_comparison_exp
  author: users_bool_exp
  author_id: Int_comparison_exp
  comments: comments_bool_exp
  content: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  likes: likes_bool_exp
  tags: tags_bool_exp
  title: String_comparison_exp
}

"input type for incrementing integer column in table \"articles\""
input articles_inc_input {
  author_id: Int
  id: Int
}

"input type for inserting data into table \"articles\""
input articles_insert_input {
  about: String
  author: users_obj_rel_insert_input
  author_id: Int
  comments: comments_arr_rel_insert_input
  content: String
  created_at: timestamptz
  id: Int
  likes: likes_arr_rel_insert_input
  tags: tags_arr_rel_insert_input
  title: String
}

"order by max() on columns of table \"articles\""
input articles_max_order_by {
  about: order_by
  author_id: order_by
  content: order_by
  created_at: order_by
  id: order_by
  title: order_by
}

"order by min() on columns of table \"articles\""
input articles_min_order_by {
  about: order_by
  author_id: order_by
  content: order_by
  created_at: order_by
  id: order_by
  title: order_by
}

"input type for inserting object relation for remote table \"articles\""
input articles_obj_rel_insert_input {
  data: articles_insert_input!
  on_conflict: articles_on_conflict
}

"on conflict condition type for table \"articles\""
input articles_on_conflict {
  constraint: articles_constraint!
  update_columns: [articles_update_column!]!
  where: articles_bool_exp
}

"ordering options when selecting data from \"articles\""
input articles_order_by {
  about: order_by
  author: users_order_by
  author_id: order_by
  comments_aggregate: comments_aggregate_order_by
  content: order_by
  created_at: order_by
  id: order_by
  likes_aggregate: likes_aggregate_order_by
  tags_aggregate: tags_aggregate_order_by
  title: order_by
}

"primary key columns input for table: \"articles\""
input articles_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"articles\""
input articles_set_input {
  about: String
  author_id: Int
  content: String
  created_at: timestamptz
  id: Int
  title: String
}

"order by stddev() on columns of table \"articles\""
input articles_stddev_order_by {
  author_id: order_by
  id: order_by
}

"order by stddev_pop() on columns of table \"articles\""
input articles_stddev_pop_order_by {
  author_id: order_by
  id: order_by
}

"order by stddev_samp() on columns of table \"articles\""
input articles_stddev_samp_order_by {
  author_id: order_by
  id: order_by
}

"order by sum() on columns of table \"articles\""
input articles_sum_order_by {
  author_id: order_by
  id: order_by
}

"order by var_pop() on columns of table \"articles\""
input articles_var_pop_order_by {
  author_id: order_by
  id: order_by
}

"order by var_samp() on columns of table \"articles\""
input articles_var_samp_order_by {
  author_id: order_by
  id: order_by
}

"order by variance() on columns of table \"articles\""
input articles_variance_order_by {
  author_id: order_by
  id: order_by
}

"order by aggregate values of table \"comments\""
input comments_aggregate_order_by {
  avg: comments_avg_order_by
  count: order_by
  max: comments_max_order_by
  min: comments_min_order_by
  stddev: comments_stddev_order_by
  stddev_pop: comments_stddev_pop_order_by
  stddev_samp: comments_stddev_samp_order_by
  sum: comments_sum_order_by
  var_pop: comments_var_pop_order_by
  var_samp: comments_var_samp_order_by
  variance: comments_variance_order_by
}

"input type for inserting array relation for remote table \"comments\""
input comments_arr_rel_insert_input {
  data: [comments_insert_input!]!
  on_conflict: comments_on_conflict
}

"order by avg() on columns of table \"comments\""
input comments_avg_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"Boolean expression to filter rows from the table \"comments\". All fields are combined with a logical 'AND'."
input comments_bool_exp {
  _and: [comments_bool_exp]
  _not: comments_bool_exp
  _or: [comments_bool_exp]
  article: articles_bool_exp
  article_id: Int_comparison_exp
  comment: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  user: users_bool_exp
  user_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"comments\""
input comments_inc_input {
  article_id: Int
  id: Int
  user_id: Int
}

"input type for inserting data into table \"comments\""
input comments_insert_input {
  article: articles_obj_rel_insert_input
  article_id: Int
  comment: String
  created_at: timestamptz
  id: Int
  user: users_obj_rel_insert_input
  user_id: Int
}

"order by max() on columns of table \"comments\""
input comments_max_order_by {
  article_id: order_by
  comment: order_by
  created_at: order_by
  id: order_by
  user_id: order_by
}

"order by min() on columns of table \"comments\""
input comments_min_order_by {
  article_id: order_by
  comment: order_by
  created_at: order_by
  id: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"comments\""
input comments_obj_rel_insert_input {
  data: comments_insert_input!
  on_conflict: comments_on_conflict
}

"on conflict condition type for table \"comments\""
input comments_on_conflict {
  constraint: comments_constraint!
  update_columns: [comments_update_column!]!
  where: comments_bool_exp
}

"ordering options when selecting data from \"comments\""
input comments_order_by {
  article: articles_order_by
  article_id: order_by
  comment: order_by
  created_at: order_by
  id: order_by
  user: users_order_by
  user_id: order_by
}

"primary key columns input for table: \"comments\""
input comments_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"comments\""
input comments_set_input {
  article_id: Int
  comment: String
  created_at: timestamptz
  id: Int
  user_id: Int
}

"order by stddev() on columns of table \"comments\""
input comments_stddev_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by stddev_pop() on columns of table \"comments\""
input comments_stddev_pop_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by stddev_samp() on columns of table \"comments\""
input comments_stddev_samp_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by sum() on columns of table \"comments\""
input comments_sum_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by var_pop() on columns of table \"comments\""
input comments_var_pop_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by var_samp() on columns of table \"comments\""
input comments_var_samp_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by variance() on columns of table \"comments\""
input comments_variance_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by aggregate values of table \"follows\""
input follows_aggregate_order_by {
  avg: follows_avg_order_by
  count: order_by
  max: follows_max_order_by
  min: follows_min_order_by
  stddev: follows_stddev_order_by
  stddev_pop: follows_stddev_pop_order_by
  stddev_samp: follows_stddev_samp_order_by
  sum: follows_sum_order_by
  var_pop: follows_var_pop_order_by
  var_samp: follows_var_samp_order_by
  variance: follows_variance_order_by
}

"input type for inserting array relation for remote table \"follows\""
input follows_arr_rel_insert_input {
  data: [follows_insert_input!]!
  on_conflict: follows_on_conflict
}

"order by avg() on columns of table \"follows\""
input follows_avg_order_by {
  following_id: order_by
  id: order_by
  user_id: order_by
}

"Boolean expression to filter rows from the table \"follows\". All fields are combined with a logical 'AND'."
input follows_bool_exp {
  _and: [follows_bool_exp]
  _not: follows_bool_exp
  _or: [follows_bool_exp]
  following_id: Int_comparison_exp
  id: Int_comparison_exp
  user: users_bool_exp
  user_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"follows\""
input follows_inc_input {
  following_id: Int
  id: Int
  user_id: Int
}

"input type for inserting data into table \"follows\""
input follows_insert_input {
  following_id: Int
  id: Int
  user: users_obj_rel_insert_input
  user_id: Int
}

"order by max() on columns of table \"follows\""
input follows_max_order_by {
  following_id: order_by
  id: order_by
  user_id: order_by
}

"order by min() on columns of table \"follows\""
input follows_min_order_by {
  following_id: order_by
  id: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"follows\""
input follows_obj_rel_insert_input {
  data: follows_insert_input!
  on_conflict: follows_on_conflict
}

"on conflict condition type for table \"follows\""
input follows_on_conflict {
  constraint: follows_constraint!
  update_columns: [follows_update_column!]!
  where: follows_bool_exp
}

"ordering options when selecting data from \"follows\""
input follows_order_by {
  following_id: order_by
  id: order_by
  user: users_order_by
  user_id: order_by
}

"primary key columns input for table: \"follows\""
input follows_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"follows\""
input follows_set_input {
  following_id: Int
  id: Int
  user_id: Int
}

"order by stddev() on columns of table \"follows\""
input follows_stddev_order_by {
  following_id: order_by
  id: order_by
  user_id: order_by
}

"order by stddev_pop() on columns of table \"follows\""
input follows_stddev_pop_order_by {
  following_id: order_by
  id: order_by
  user_id: order_by
}

"order by stddev_samp() on columns of table \"follows\""
input follows_stddev_samp_order_by {
  following_id: order_by
  id: order_by
  user_id: order_by
}

"order by sum() on columns of table \"follows\""
input follows_sum_order_by {
  following_id: order_by
  id: order_by
  user_id: order_by
}

"order by var_pop() on columns of table \"follows\""
input follows_var_pop_order_by {
  following_id: order_by
  id: order_by
  user_id: order_by
}

"order by var_samp() on columns of table \"follows\""
input follows_var_samp_order_by {
  following_id: order_by
  id: order_by
  user_id: order_by
}

"order by variance() on columns of table \"follows\""
input follows_variance_order_by {
  following_id: order_by
  id: order_by
  user_id: order_by
}

"expression to compare columns of type json. All fields are combined with logical 'AND'."
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

"order by aggregate values of table \"likes\""
input likes_aggregate_order_by {
  avg: likes_avg_order_by
  count: order_by
  max: likes_max_order_by
  min: likes_min_order_by
  stddev: likes_stddev_order_by
  stddev_pop: likes_stddev_pop_order_by
  stddev_samp: likes_stddev_samp_order_by
  sum: likes_sum_order_by
  var_pop: likes_var_pop_order_by
  var_samp: likes_var_samp_order_by
  variance: likes_variance_order_by
}

"input type for inserting array relation for remote table \"likes\""
input likes_arr_rel_insert_input {
  data: [likes_insert_input!]!
  on_conflict: likes_on_conflict
}

"order by avg() on columns of table \"likes\""
input likes_avg_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"Boolean expression to filter rows from the table \"likes\". All fields are combined with a logical 'AND'."
input likes_bool_exp {
  _and: [likes_bool_exp]
  _not: likes_bool_exp
  _or: [likes_bool_exp]
  article: articles_bool_exp
  article_id: Int_comparison_exp
  id: Int_comparison_exp
  user: users_bool_exp
  user_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"likes\""
input likes_inc_input {
  article_id: Int
  id: Int
  user_id: Int
}

"input type for inserting data into table \"likes\""
input likes_insert_input {
  article: articles_obj_rel_insert_input
  article_id: Int
  id: Int
  user: users_obj_rel_insert_input
  user_id: Int
}

"order by max() on columns of table \"likes\""
input likes_max_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by min() on columns of table \"likes\""
input likes_min_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"input type for inserting object relation for remote table \"likes\""
input likes_obj_rel_insert_input {
  data: likes_insert_input!
  on_conflict: likes_on_conflict
}

"on conflict condition type for table \"likes\""
input likes_on_conflict {
  constraint: likes_constraint!
  update_columns: [likes_update_column!]!
  where: likes_bool_exp
}

"ordering options when selecting data from \"likes\""
input likes_order_by {
  article: articles_order_by
  article_id: order_by
  id: order_by
  user: users_order_by
  user_id: order_by
}

"primary key columns input for table: \"likes\""
input likes_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"likes\""
input likes_set_input {
  article_id: Int
  id: Int
  user_id: Int
}

"order by stddev() on columns of table \"likes\""
input likes_stddev_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by stddev_pop() on columns of table \"likes\""
input likes_stddev_pop_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by stddev_samp() on columns of table \"likes\""
input likes_stddev_samp_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by sum() on columns of table \"likes\""
input likes_sum_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by var_pop() on columns of table \"likes\""
input likes_var_pop_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by var_samp() on columns of table \"likes\""
input likes_var_samp_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by variance() on columns of table \"likes\""
input likes_variance_order_by {
  article_id: order_by
  id: order_by
  user_id: order_by
}

"order by aggregate values of table \"profile\""
input profile_aggregate_order_by {
  avg: profile_avg_order_by
  count: order_by
  max: profile_max_order_by
  min: profile_min_order_by
  stddev: profile_stddev_order_by
  stddev_pop: profile_stddev_pop_order_by
  stddev_samp: profile_stddev_samp_order_by
  sum: profile_sum_order_by
  var_pop: profile_var_pop_order_by
  var_samp: profile_var_samp_order_by
  variance: profile_variance_order_by
}

"input type for inserting array relation for remote table \"profile\""
input profile_arr_rel_insert_input {
  data: [profile_insert_input!]!
}

"order by avg() on columns of table \"profile\""
input profile_avg_order_by {
  user_id: order_by
}

"Boolean expression to filter rows from the table \"profile\". All fields are combined with a logical 'AND'."
input profile_bool_exp {
  _and: [profile_bool_exp]
  _not: profile_bool_exp
  _or: [profile_bool_exp]
  bio: String_comparison_exp
  email: String_comparison_exp
  follows: follows_bool_exp
  profile_image: String_comparison_exp
  user_id: Int_comparison_exp
  username: String_comparison_exp
}

"input type for incrementing integer column in table \"profile\""
input profile_inc_input {
  user_id: Int
}

"input type for inserting data into table \"profile\""
input profile_insert_input {
  bio: String
  email: String
  follows: follows_arr_rel_insert_input
  profile_image: String
  user_id: Int
  username: String
}

"order by max() on columns of table \"profile\""
input profile_max_order_by {
  bio: order_by
  email: order_by
  profile_image: order_by
  user_id: order_by
  username: order_by
}

"order by min() on columns of table \"profile\""
input profile_min_order_by {
  bio: order_by
  email: order_by
  profile_image: order_by
  user_id: order_by
  username: order_by
}

"input type for inserting object relation for remote table \"profile\""
input profile_obj_rel_insert_input {
  data: profile_insert_input!
}

"ordering options when selecting data from \"profile\""
input profile_order_by {
  bio: order_by
  email: order_by
  follows_aggregate: follows_aggregate_order_by
  profile_image: order_by
  user_id: order_by
  username: order_by
}

"input type for updating data in table \"profile\""
input profile_set_input {
  bio: String
  email: String
  profile_image: String
  user_id: Int
  username: String
}

"order by stddev() on columns of table \"profile\""
input profile_stddev_order_by {
  user_id: order_by
}

"order by stddev_pop() on columns of table \"profile\""
input profile_stddev_pop_order_by {
  user_id: order_by
}

"order by stddev_samp() on columns of table \"profile\""
input profile_stddev_samp_order_by {
  user_id: order_by
}

"order by sum() on columns of table \"profile\""
input profile_sum_order_by {
  user_id: order_by
}

"order by var_pop() on columns of table \"profile\""
input profile_var_pop_order_by {
  user_id: order_by
}

"order by var_samp() on columns of table \"profile\""
input profile_var_samp_order_by {
  user_id: order_by
}

"order by variance() on columns of table \"profile\""
input profile_variance_order_by {
  user_id: order_by
}

"order by aggregate values of table \"tags\""
input tags_aggregate_order_by {
  avg: tags_avg_order_by
  count: order_by
  max: tags_max_order_by
  min: tags_min_order_by
  stddev: tags_stddev_order_by
  stddev_pop: tags_stddev_pop_order_by
  stddev_samp: tags_stddev_samp_order_by
  sum: tags_sum_order_by
  var_pop: tags_var_pop_order_by
  var_samp: tags_var_samp_order_by
  variance: tags_variance_order_by
}

"input type for inserting array relation for remote table \"tags\""
input tags_arr_rel_insert_input {
  data: [tags_insert_input!]!
  on_conflict: tags_on_conflict
}

"order by avg() on columns of table \"tags\""
input tags_avg_order_by {
  article_id: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"tags\". All fields are combined with a logical 'AND'."
input tags_bool_exp {
  _and: [tags_bool_exp]
  _not: tags_bool_exp
  _or: [tags_bool_exp]
  article: articles_bool_exp
  article_id: Int_comparison_exp
  id: Int_comparison_exp
  tag: String_comparison_exp
}

"input type for incrementing integer column in table \"tags\""
input tags_inc_input {
  article_id: Int
  id: Int
}

"input type for inserting data into table \"tags\""
input tags_insert_input {
  article: articles_obj_rel_insert_input
  article_id: Int
  id: Int
  tag: String
}

"order by max() on columns of table \"tags\""
input tags_max_order_by {
  article_id: order_by
  id: order_by
  tag: order_by
}

"order by min() on columns of table \"tags\""
input tags_min_order_by {
  article_id: order_by
  id: order_by
  tag: order_by
}

"input type for inserting object relation for remote table \"tags\""
input tags_obj_rel_insert_input {
  data: tags_insert_input!
  on_conflict: tags_on_conflict
}

"on conflict condition type for table \"tags\""
input tags_on_conflict {
  constraint: tags_constraint!
  update_columns: [tags_update_column!]!
  where: tags_bool_exp
}

"ordering options when selecting data from \"tags\""
input tags_order_by {
  article: articles_order_by
  article_id: order_by
  id: order_by
  tag: order_by
}

"primary key columns input for table: \"tags\""
input tags_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"tags\""
input tags_set_input {
  article_id: Int
  id: Int
  tag: String
}

"order by stddev() on columns of table \"tags\""
input tags_stddev_order_by {
  article_id: order_by
  id: order_by
}

"order by stddev_pop() on columns of table \"tags\""
input tags_stddev_pop_order_by {
  article_id: order_by
  id: order_by
}

"order by stddev_samp() on columns of table \"tags\""
input tags_stddev_samp_order_by {
  article_id: order_by
  id: order_by
}

"order by sum() on columns of table \"tags\""
input tags_sum_order_by {
  article_id: order_by
  id: order_by
}

"order by var_pop() on columns of table \"tags\""
input tags_var_pop_order_by {
  article_id: order_by
  id: order_by
}

"order by var_samp() on columns of table \"tags\""
input tags_var_samp_order_by {
  article_id: order_by
  id: order_by
}

"order by variance() on columns of table \"tags\""
input tags_variance_order_by {
  article_id: order_by
  id: order_by
}

"expression to compare columns of type timestamptz. All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"order by aggregate values of table \"users\""
input users_aggregate_order_by {
  avg: users_avg_order_by
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
  stddev: users_stddev_order_by
  stddev_pop: users_stddev_pop_order_by
  stddev_samp: users_stddev_samp_order_by
  sum: users_sum_order_by
  var_pop: users_var_pop_order_by
  var_samp: users_var_samp_order_by
  variance: users_variance_order_by
}

"input type for inserting array relation for remote table \"users\""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!
  on_conflict: users_on_conflict
}

"order by avg() on columns of table \"users\""
input users_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"users\". All fields are combined with a logical 'AND'."
input users_bool_exp {
  _and: [users_bool_exp]
  _not: users_bool_exp
  _or: [users_bool_exp]
  articles: articles_bool_exp
  bio: String_comparison_exp
  email: String_comparison_exp
  follows: follows_bool_exp
  id: Int_comparison_exp
  password_hash: String_comparison_exp
  profile_image: String_comparison_exp
  username: String_comparison_exp
}

"input type for incrementing integer column in table \"users\""
input users_inc_input {
  id: Int
}

"input type for inserting data into table \"users\""
input users_insert_input {
  articles: articles_arr_rel_insert_input
  bio: String
  email: String
  follows: follows_arr_rel_insert_input
  id: Int
  password_hash: String
  profile_image: String
  username: String
}

"order by max() on columns of table \"users\""
input users_max_order_by {
  bio: order_by
  email: order_by
  id: order_by
  password_hash: order_by
  profile_image: order_by
  username: order_by
}

"order by min() on columns of table \"users\""
input users_min_order_by {
  bio: order_by
  email: order_by
  id: order_by
  password_hash: order_by
  profile_image: order_by
  username: order_by
}

"input type for inserting object relation for remote table \"users\""
input users_obj_rel_insert_input {
  data: users_insert_input!
  on_conflict: users_on_conflict
}

"on conflict condition type for table \"users\""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]!
  where: users_bool_exp
}

"ordering options when selecting data from \"users\""
input users_order_by {
  articles_aggregate: articles_aggregate_order_by
  bio: order_by
  email: order_by
  follows_aggregate: follows_aggregate_order_by
  id: order_by
  password_hash: order_by
  profile_image: order_by
  username: order_by
}

"primary key columns input for table: \"users\""
input users_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"users\""
input users_set_input {
  bio: String
  email: String
  id: Int
  password_hash: String
  profile_image: String
  username: String
}

"order by stddev() on columns of table \"users\""
input users_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"users\""
input users_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"users\""
input users_stddev_samp_order_by {
  id: order_by
}

"order by sum() on columns of table \"users\""
input users_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"users\""
input users_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"users\""
input users_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"users\""
input users_variance_order_by {
  id: order_by
}
